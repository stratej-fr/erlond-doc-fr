<?xml version="1.0" ?><xliff version="1.2">
  <file datatype="DOCX" original="elrond-whitepaperdocx" source-language="en" target-language="fr">
    <body>
      <trans-unit id="1" resname="29fbfcc4f73038a88b5f5b0d333eb131">
        <source>Elrond</source>
        <target>Elrond</target>
      </trans-unit>
      <trans-unit id="2" resname="273a170712221fe4d2ed72df8af64b01">
        <source>A Highly Scalable Public Blockchain via Adaptive State Sharding and Secure Proof of Stake</source>
        <target>Une Blockchain publique hautement scalable grâce au partitionnement horizontal (sharding) d'états adaptatif et au consensus à preuve d'enjeu sécurisée (Secure Proof of Stake - SPoS)</target>
      </trans-unit>
      <trans-unit id="3" resname="e9028019c5ffe73b7ed91d9bbed5038b">
        <source>[Technical whitepaper — release 2 — revision 1]</source>
        <target>[Livre blanc technique - Edition 2 - révision 1] </target>
      </trans-unit>
      <trans-unit id="4" resname="3f43af8100380b0f7e4a35a6b50f0b91">
        <source>Updated chapters: [5 - 13] June 19, 2019 - The Elrond Team https://www.elrond.com/</source>
        <target>mises à jour des chapitres: [5 - 13] 19 Juin 2019 – L’équipe Elrond https://www.elrond.com/</target>
      </trans-unit>
      <trans-unit id="5" resname="6e1848f0e9af3e5e3e5a7c1f726e8827">
        <source>Abstract—The advent of secure public blockchains through Bitcoin and later Ethereum, has brought forth a notable degree of   interest   and   capital   influx, providing   the   premise   for   a global wave of permissionless innovation. Despite lofty promises, creating a decentralized, secure and scalable public blockchain has proved to be a strenuous task.</source>
        <target>Résumé - L'avènement de la Blockchain publique sécurisée avec Bitcoin puis Ethereum, a suscité un intérêt notable et l'afflux de capitaux, fournissant les prémisses d'une vague mondiale d'innovation ouverte à tous. Malgré de grandes promesses, la création d'une Blockchain décentralisée, sécurisée et évolutive s'est révélée être une tâche ardue.</target>
      </trans-unit>
      <trans-unit id="6" resname="e4d8dbb60a8ccd7a619ef930993c5cac">
        <source>This  paper  proposes  Elrond,  a  novel  architecture  which  goes beyond  state  of  the  art  by  introducing  a  genuine  state  sharding scheme  for  practical  scalability,  eliminating  energy  and  computational  waste  while  ensuring  distributed  fairness  through  a Secure Proof of Stake (SPoS) consensus. Having a strong focus on security, Elrond’s network is built to ensure resistance to known security problems like Sybil attack, Nothing at Stake attack and others.  In an ecosystem that strives for interconnectivity, our solution for smart contracts offers an EVM compliant engine to ensure interoperability by design.</source>
        <target>Ce document est consacré à Elrond, une nouvelle architecture qui transcende l'état de l'art en introduisant un véritable mécanisme de partitionnement d'états (State Sharding) clé de voute d'une scalabilité opérationnelle, éliminant les gaspillages d'énergie et de calcul tout en garantissant une équité distribuée grâce à un consensus à preuve d'enjeu sécurisée (SPoS). En mettant l'accent sur la sécurité, le réseau d'Elrond est construit pour résister aux problèmes de sécurité connus comme l'attaque Sybil, l'attaque &quot;Rien à perdre&quot; et d'autres. Dans un écosystème qui prône l'interconnectivité, notre solution pour implémenter les contrats intelligents (Smart Contracts) offre un moteur compatible avec EVM afin d'inscrire l'interopérabilité dans son ADN.</target>
      </trans-unit>
      <trans-unit id="7" resname="9dad5988e4553aaa4b5ffc4b97a3deca">
        <source>Preliminary simulations and testnet results reflect that Elrond exceeds Visa’s average throughput and achieves an improvement beyond  three  orders  of  magnitude  or  1000x  compared  to  the existing  viable  approaches,  while  drastically  reducing  the  costs of bootstrapping and storage to ensure long term sustainability.</source>
        <target>Les simulations préliminaires et les résultats du testnet montrent qu'Elrond dépasse le débit moyen de Visa en l'améliorant d'un facteur supérieur à 3, ou, d'un facteur 1000 par rapport aux approches viables existantes, tout en réduisant considérablement les coûts d'amorçage et de stockage pour assurer la durabilité à long terme.</target>
      </trans-unit>
      <trans-unit id="8" resname="b2ff688f2ee923693b53076b11eb0a2a">
        <source>I  Introduction</source>
        <target>I Introduction</target>
      </trans-unit>
      <trans-unit id="9" resname="1f757e3a7c0044509a8210caca983e7a">
        <source>1  General aspects</source>
        <target>1 Aspects généraux</target>
      </trans-unit>
      <trans-unit id="10" resname="13d94a5756462841d18ab61061ee3ab6">
        <source>Cryptocurrency  and  smart  contract  platforms  such  as  Bit- coin  and  Ethereum  have  sparked  considerable  interest  and have  become  promising  solutions  for  electronic  payments, decentralized applications and potential digital stores of value. However,  when  compared  to  their  centralized  counterparts in  key  metrics  [1],  the  current  state  of  affairs  suggests  that present public blockchain iterations exhibit severe limitations, particularly  with  respect  to  scalability,  hindering  their  main- stream  adoption  and  delaying  public  use.  In fact,  it  has proved  extremely  challenging  to  deal  with  the  current  engineering boundaries imposed by the trade-offs in the blockchain trilemma paradigm [2]. Several solutions have been proposed, but  few  of  them  have  shown  significant  and  viable  results. Thus,  in  order  to  solve  the  scalability  problem,  a  complete rethinking of public blockchain infrastructures was required.</source>
        <target>Les plates-formes de crypto-monnaie et de contrats intelligents (Smart Contracts) telles que Bitcoin et Ethereum ont suscité un intérêt considérable et sont devenues des solutions prometteuses pour les paiements électroniques, les applications décentralisées et les réserves numériques potentielles de valeur. Toutefois, en comparaison des indicateurs clés de leurs homologues centralisés[1], l'état actuel des choses suggère que les versions actuelles des Blockchains publiques présentent de sérieuses limitations, notamment en ce qui concerne la scalabilité, ce qui fait obstacle à leur adoption par le grand public et lui en retarde son utilisation. En fait, il s'est avéré extrêmement difficile de gérer les limites techniques actuelles imposées par les compromis du paradigme du trilemme des Blockchains [2]. Plusieurs solutions ont été proposées, mais peu d'entre elles ont donné des résultats significatifs et viables. Ainsi, pour résoudre le problème de la scalabilité, il a fallu repenser complètement les infrastructures de la Blockchain publique.</target>
      </trans-unit>
      <trans-unit id="11" resname="084eae7baf007956e5a43c4bd7c3133c">
        <source>2  Defining the challenges</source>
        <target>2 Définir les défis</target>
      </trans-unit>
      <trans-unit id="12" resname="bfb9bb53585993a5a0fe407b381af710">
        <source>Several challenges must be  addressed  properly  in  the  pro- cess  of  creating  an  innovative  public  blockchain  solution designed to scale:</source>
        <target>Plusieurs défis doivent être correctement relevés dans le processus de création d'une solution innovante de blockchain publique conçue pour une mise à l'échelle:</target>
      </trans-unit>
      <trans-unit id="13" resname="b7931eac36a186ba3e54702a17737ff0">
        <source>•   Full decentralization  -  Eliminating  the  need  for  any trusted  third  party,  hence  removing  any  single  point  of failure;</source>
        <target>• Décentralisation complète - Élimination du besoin de tout tiers de confiance, supprimant ainsi tout point de défaillance unique;</target>
      </trans-unit>
      <trans-unit id="14" resname="23b57dca80c8d41c5f29db1963186e8d">
        <source>•   Robust   security   -   Allowing   secure   transactions   and preventing any attacks based on known attack vectors;</source>
        <target>Sécurité robuste – Permettant des transactions sécurisées et empêchant toute attaque basée sur des vecteurs connus;</target>
      </trans-unit>
      <trans-unit id="15" resname="735cebababead97849ad75f365b1fc4d">
        <source>•   High  scalability  -  Enabling  the  network  to  achieve  a performance at least equal to the centralized counterpart, as measured in TPS;</source>
        <target>Haute scalabilité - Permettre au réseau d'atteindre une performance en transactions par seconde (TPS) au moins égale à son homologue centralisé;</target>
      </trans-unit>
      <trans-unit id="16" resname="0397a93669740e11e22401995481c62d">
        <source>•   Efficiency  -  Performing  all  network  services  with  mini- mal energy and computational requirements;</source>
        <target>Efficacité - Exécution de tous les services réseau avec des exigences énergétiques et informatiques minimales;</target>
      </trans-unit>
      <trans-unit id="17" resname="3ea6cdde2968e126cdac8276fbef553f">
        <source>•   Bootstrapping  and  storage  enhancement - Ensuring a competitive cost for data storage and synchronization;</source>
        <target>• Amorçage et amélioration du stockage - Assurant un coût compétitif pour le stockage et la synchronisation des données;</target>
      </trans-unit>
      <trans-unit id="18" resname="b22568042e25ccbcac667a752c86dcb3">
        <source>•   Cross-chain interoperability - Enforced by design, per- mitting unlimited communication with external services. Starting  from  the  above  challenges,  we’ve  created Elrond as  a  complete  rethinking  of  public  blockchain  infrastructure, specifically designed to be secure, efficient, scalable and inter-operable. Elrond’s main contribution rests on two cornerstone building blocks:</source>
        <target>• Interopérabilité entre chaînes - renforcée nativement à la conception, permettant une communication illimitée avec les services externes. À partir des défis ci-dessus, nous avons créé Elrond en repensant complètement l'infrastructure de Blockchain publique, spécialement conçue pour être sécurisée, efficace et interopérable. La principale contribution d'Elrond repose sur 2 piliers fondamentaux de construction: </target>
      </trans-unit>
      <trans-unit id="19" resname="b38e0195d2275ad62b695cd7ed022506">
        <source>1)  A genuine State Sharding approach: effectively partitioning  the  blockchain  and  account  state  into  multiple shards,  handled  in  parallel  by  different  participating validators;</source>
        <target>1) Un véritable mécanisme de partitionnement horizontal d'états (State Sharding) : partitionner efficacement la Blockchain et l'état des comptes en plusieurs fragments, gérés en parallèle par différents validateurs participants;</target>
      </trans-unit>
      <trans-unit id="20" resname="6813ceaa25b456a48f641efbf2ad2c7a">
        <source>2)  Secure   Proof   of   Stake   consensus   mechanism:  an improved variation of Proof of Stake (PoS) that ensures long term security and distributed fairness, while eliminating the need for energy intensive PoW algorithms.</source>
        <target>2) Un mécanisme de consensus sécurisé à preuve d'enjeu : une variante améliorée de la preuve d'enjeu (PoS) qui garantit la sécurité à long terme et l'équité distribuée, tout en éliminant le besoin d'algorithmes PoW énergivores.</target>
      </trans-unit>
      <trans-unit id="21" resname="31f78731f319316c141aff61c5e9ca16">
        <source>3  Adaptive State Sharding</source>
        <target>3 Partitionnement d'état adaptatif</target>
      </trans-unit>
      <trans-unit id="22" resname="9e0c53153f9610af0eecf1e2c94c13db">
        <source>Elrond  proposes  a  dynamically  adaptive  sharding  mechanism  that  enables  shard  computation  and  reorganizing  based on  necessity  and  the  number  of  active  network  nodes.  The reassignment  of  nodes  in  the  shards  at  the  beginning  of each  epoch  is  progressive  and  nondeterministic,  inducing  no temporary  liveness  penalties.  Adaptive  state  sharding  comes with additional challenges compared to the static model. One of  the  key-points  resides  in  how  shard-splitting  and  shard- merging is done to prevent overall latency penalties introduced by  the synchronization/communication needs  when  the shard number changes. Latency, in this case, is the communication overhead required by nodes, in order to retrieve the new state, once their shard address space assignment has been modified.</source>
        <target>Elrond propose un mécanisme de partage adaptatif dynamique qui permet le calcul et la réorganisation des fragments en fonction du besoin et du nombre de nœuds réseau actifs. La réaffectation des nœuds dans les fragments au début de chaque époque est progressive et non déterministe, n'induisant aucune pénalité temporaire sur la note de performance. Le partage d'état adaptatif s'accompagne de défis supplémentaires par rapport au modèle statique. L'un des points clés réside dans la façon dont le partitionnement et la fusion des fragments sont effectués pour éviter les pénalités de latence globales introduites par les besoins de synchronisation / communication lorsque le nombre de fragments change. La latence, dans ce cas, est la surcharge de communication requise par les nœuds, afin de récupérer le nouvel état, une fois que leur affectation d'espace d'adressage de fragment a été modifiée.</target>
      </trans-unit>
      <trans-unit id="23" resname="d47841753285c5963b46da86d66af490">
        <source>Elrond proposes a solution for this problem below, but first some  notions have  to  be  defined: users  and  nodes. Users  are external  actors  and  can  be  identified  by  an  unique  account address;  nodes  are  computers/devices  in  the  Elrond  network that run our protocol. Notions like users, nodes, addresses will be further described in chapter II.1 - Entities.</source>
        <target>Elrond propose une solution au problème ci-dessous, mais d'abord quelques notions doivent être définies : utilisateurs et nœuds. Les utilisateurs sont des acteurs externes et peuvent être identifiés par une adresse de compte unique ; les nœuds sont des ordinateurs/appareils du réseau Elrond qui exécutent notre protocole. Des notions telles que les utilisateurs, les nœuds et les adresses seront décrites plus en détail dans le chapitre II.1 - Entités.</target>
      </trans-unit>
      <trans-unit id="24" resname="4defe7441748620fd7fa0978fed61bbb">
        <source>Elrond solves this challenge by:</source>
        <target>Elrond résout ce défi en :</target>
      </trans-unit>
      <trans-unit id="25" resname="b1ce4e3bad610be9408457fd05c7dd55">
        <source>1)  Dividing  the  account  address  space  in  shards,  using  a binary tree which can be built with the sole requirement of  knowing  the  exact  number  of  shards  in  a  certain epoch.  Using  this  method,  the  accumulated  latency  is reduced  and  the  network  liveness  is  improved  in  two ways. First, thanks to the designed model, the dividing of the account address space is predetermined by hierarchy. Hence,  there  is  no  split  overhead,  meaning  that  one shard  breaks  into  two  shards,  each  of  them  keeping only one half of the previous address space in addition to  the  associated  state.  Second,  the  latency  is  reduced through the state redundancy mechanism, as the merge is prepared by retaining the state in the sibling nodes.</source>
        <target>1) Divisant l'espace d'adressage des comptes dans les fragments, en utilisant un arbre binaire qui peut être construit avec la seule exigence de connaissance exact du nombre de fragments à une époque donnée. Cette méthode permet de réduire la latence accumulée et d'améliorer l'efficacité du réseau de deux manières. Premièrement, grâce au modèle conçu, la division de l'espace d'adressage des comptes est prédéterminée par la hiérarchie. Ainsi, il n'y a pas de surcharge de division, ce qui signifie qu'un fragment se divise en deux. Chacun d'eux  ne conservant que la moitié de l'espace d'adressage précédent en plus de l'état associé. Ensuite, la latence est réduite grâce au mécanisme de redondance d'état, car la fusion est préparée en conservant l'état dans les nœuds de meme parent.</target>
      </trans-unit>
      <trans-unit id="26" resname="ac2ac90fe3f54788b73479a6001de2d5">
        <source>2)  Introducing a technique of balancing the nodes in each shard,  to  achieve  overall  architecture  equilibrium.  This technique ensures  a  balanced  workload  and  reward  for each node in the network.</source>
        <target>2) Introduisant une technique d'équilibrage des nœuds dans chaque fragment, afin d'obtenir un équilibre global de l'architecture. Cette technique assure une charge de travail équilibrée et une récompense pour chaque nœud du réseau.</target>
      </trans-unit>
      <trans-unit id="27" resname="9675986493225ed6620897811a9c88a7">
        <source>3)  Designing a  built-in  mechanism  for  automatic  transac- tion  routing  in  the  corresponding  shards,  considerably reduces  latency  as  a  result.  The  routing  algorithm  is described in chapter IV.4 - Elrond sharding approach.</source>
        <target>3) Concevant un mécanisme intégré pour l'acheminement automatique des transactions dans les fragments correspondants, ce qui réduit considérablement la latence. L'algorithme de routage est décrit au chapitre IV.4 - Approche des Shards d'Elrond.</target>
      </trans-unit>
      <trans-unit id="28" resname="0abe4ff7551fd59e5aac84f0a6fdfb90">
        <source>4)  In order to achieve considerable improvements with re- spect to bootstrapping and storage, Elrond makes use of a shard pruning mechanism. This ensures sustainability of  our  architecture  even  with  a  throughput  of  tens  of thousands of transactions per second (TPS).</source>
        <target>4) Afin d'obtenir des améliorations considérables tout en ne pénalisant pas l'initialisation au démarrage et le stockage, Elrond utilise un mécanisme d'élagage des fragments. Cela assure la durabilité de notre architecture, même avec un débit de dizaines de milliers de transactions par seconde (TPS).</target>
      </trans-unit>
      <trans-unit id="29" resname="30f94d67df4b5a43db13337bc856f9ff">
        <source>4  Secure Proof of Stake (SPoS)</source>
        <target>4 Preuve d'enjeu sécurisée (SPoS ou Secure Proof of Stake)</target>
      </trans-unit>
      <trans-unit id="30" resname="275a229c04b96e3b20a1098792c9bc1f">
        <source>We  introduce  a  Secure  Proof  of  Stake  consensus  mecha- nism,  that  expands  on  Algorand’s  [3]  idea  of  a  random  se- lection mechanism, differentiating itself through the following aspects:</source>
        <target>Nous introduisons un mécanisme de consensus &quot;Preuve sûre de l'enjeu&quot;, qui développe l'idée d'Algorand [3] d'un mécanisme de sélection aléatoire, en se différenciant par les aspects suivants :</target>
      </trans-unit>
      <trans-unit id="31" resname="c722d46ddeb78e3a61aa87617d364e09">
        <source>1)  Elrond  introduces  an  improvement  which  reduces  the latency  allowing  each  node  in  the  shard  to  determine the members of the consensus group (block proposer and validators) at the beginning of a round. This is possible because  the  randomization  factor  r  is  stored  in  every block and is created by the block proposer using a BLS signature [4] on the previous r.</source>
        <target>1) Elrond introduit une amélioration qui réduit la latence en permettant à chaque nœud des fragments de déterminer les membres du groupe de consensus (proposants de bloc et valideurs) au début d'un tour. Cela est possible parce que le facteur de randomisation r est stocké dans chaque bloc et est créé par le proposant de bloc en utilisant une signature BLS [4] sur le r précédent.</target>
      </trans-unit>
      <trans-unit id="32" resname="0ea85c862833df726a6aa45d3ace5eca">
        <source>2)  The  block  proposer  is  the  validator  in  the  consensus group  who’s  hash  of  the  public  key  and  randomization factor  is  the  smallest.  In  contrast  to  Algorand’s  [3] approach,  where  the  random  committee  selection  can take up to 12 seconds, in Elrond the time necessary for random selection of the consensus group is considerably reduced  (estimated  under  100  ms)  excluding  network latency. Indeed, there is no communication requirement for this random selection process, which enables Elrond to  have  a  newly  and  randomly  selected  group  that succeeds  in  committing  a  new  block  to  the  ledger  in each round.</source>
        <target>2) Le proposant du bloc est le valideur dans le groupe de consensus dont le hachage de la clé publique et du facteur de randomisation est le plus petit. Contrairement à l'approche d'Algorand [3], où la sélection du comité aléatoire peut prendre jusqu'à 12 secondes, avec Elrond, le temps nécessaire à la sélection aléatoire du groupe de consensus est considérablement réduit (estimé à moins de 100 ms), hors latence du réseau. En effet, il n'y a pas d'exigence de communication pour ce processus de sélection aléatoire, ce qui permet à Elrond d'avoir un groupe nouvellement et aléatoirement sélectionné qui réussit à engager un nouveau bloc dans le registre à chaque tour.</target>
      </trans-unit>
      <trans-unit id="33" resname="fe88a168c5c17fdb16a396e23c1def02">
        <source> The tradeoff for this enhancement relies on the  premise  that  an  adversary  cannot  adapt  faster  than the  round’s  time  frame  and  can  choose  not  to  propose the block. A further improvement on the security of the randomness source, would be the use of verifiable delay functions  (VDFs)  in  order  to  prevent  any  tampering possibilities  of  the  randomness  source  until  it  is  too late.  Currently,  the  research  in  VDFs  is  still  ongoing-  there  only  a  few  working  (and  poorly  tested)  VDF implementations.</source>
        <target>Le compromis pour cette amélioration repose sur le principe qu'un adversaire ne peut pas s'adapter plus vite que le calendrier du cycle et peut choisir de ne pas proposer le bloc. Une autre amélioration de la sécurité de la source d'aléa serait l'utilisation de fonctions de retard vérifiables (VDF) afin d'empêcher toute possibilité de falsification de la source d'aléa jusqu'à ce qu'il soit trop tard. Actuellement, la recherche sur les VDF est toujours en cours - il n'existe que quelques implémentations VDF fonctionnelles (et mal testées).</target>
      </trans-unit>
      <trans-unit id="34" resname="57e83dfa1a70804d5f51c6c241506880">
        <source>3)  In  addition  to  the  stake  factor  generally  used  in  PoS architectures as a sole decision input, Elrond refines its consensus  mechanism  by  adding  an  additional  weight factor called rating. The node’s probability to be selected in  the  consensus  group  takes  into  consideration  both stake and rating. The rating of a block proposer is recal- culated at the end of each epoch, except in cases where slashing  should  occur,  when  the  actual  rating  decrease is  done  instantly,  adding  another  layer  of  security  by promoting meritocracy.</source>
        <target>3) En plus du facteur de mise en jeu généralement utilisé dans les architectures de PoS comme seul élément de décision, Elrond affine son mécanisme de consensus en ajoutant un facteur de pondération supplémentaire appelé notation. La probabilité que le nœud soit sélectionné dans le groupe de consensus prend en considération à la fois l'enjeu et la notation. La notation d'un proposant de bloc est recalculée à la fin de chaque époque, sauf dans les cas où des coupes devraient se produire, où la diminution réelle de la notation est faite instantanément, ajoutant une autre couche de sécurité en promouvant la méritocratie.</target>
      </trans-unit>
      <trans-unit id="35" resname="fc85a4d33dd728f90f1291906a2c4893">
        <source>4)  A   modified   BLS   multisignature   scheme   [5]   with   2 communication  rounds  is  used  by  the  consensus  group for block signing</source>
        <target>4) Un système modifié de signature multiple du BLS [5] avec 2 cycles de communication est utilisé par le groupe de consensus pour la signature en bloc</target>
      </trans-unit>
      <trans-unit id="36" resname="ae70bc50e8714048449ad01c4626a23b">
        <source>5)  Elrond considers formal verification for the critical pro- tocol implementations (e.g. SPoS consensus mechanism) in order to validate the correctness of our algorithms.</source>
        <target>5) Elrond envisage une vérification formelle pour les implémentations critiques du protocole (par exemple, le mécanisme de consensus SPoS) afin de valider la justesse de nos algorithmes.</target>
      </trans-unit>
      <trans-unit id="37" resname="40d0e21c50eca1efa308a73e9e593d55">
        <source>II  Architecture Overview</source>
        <target>II Aperçu de l'architecture</target>
      </trans-unit>
      <trans-unit id="38" resname="bc99cf21b2fad4ad72634fd860a572a3">
        <source>1  Entities</source>
        <target>1 Entités</target>
      </trans-unit>
      <trans-unit id="39" resname="6dfa334b6d50dd80177d577d060520e3">
        <source>There  are  two  main  entities  in  Elrond:  users  and  nodes. Users,  each  holding  a  (finite)  number  of  public  /  private (Pk/sk)  key  pairs  (e.g.  in  one  or  multiple  wallet  apps),  use the  Elrond  network  to  deploy  signed  transactions  for  value transfers or smart contracts’ execution. They can be identified by  one  of  their  account  addresses  (derived  from  the  public key). The nodes are represented by the devices that form the Elrond  network  and  can  be  passive  or  actively  engaged  in processing tasks. Eligible validators are active participants in Elrond’s network. Specifically, they are responsible for running consensus,  adding  blocks,  maintaining  the  state  and  being rewarded  for  their  contribution.  Each  eligible  validator  can be  uniquely  identified  by  a  public  key  constructed  through  a derivation of the address that staked the necessary amount and the node id. Relations between entities in the Elrond protocol are shown in Fig. 1.</source>
        <target>Il y a deux entités principales dans Elrond : les utilisateurs et les nœuds. Les utilisateurs détiennent tous un nombre (fini) de (Pk/sk) (par exemple dans une ou plusieurs applications de portefeuille). Ils utilisent le réseau Elrond pour déployer des transactions signées, afin de transférer de la valeur, ou pour exécuter des Smarts Contracts. Les utilisateurs sont identifiés par l'une de leurs adresses de compte (dérivées de la clé publique). Les nœuds sont représentés par les terminaux dont est constitué le réseau Elrond, et peuvent être engagés passivement ou activement dans le traitement des tâches. Les validateurs éligibles sont des participants actifs dans le réseau Elrond. Plus précisément, ils sont chargés de l’application du consensus, de l'ajout de blocs, du maintien du statut, en échange de quoi, ils perçoivent des récompenses. Chaque validateur éligible est identifié de manière unique par une clé publique dérivée à la fois de l'adresse où est déposé le collatéral, et aussi de l'identifiant du nœud.</target>
      </trans-unit>
      <trans-unit id="40" resname="057b5d569dd221414a73eba209170615">
        <source>Fig. 1: Relations between Elrond entities</source>
        <target>Fig. 1 : Relations entre les entités Elrond</target>
      </trans-unit>
      <trans-unit id="41" resname="344d66270a6a39d863185f5bde7c87d0">
        <source>Furthermore, the network is divided into smaller units called shards.  An  eligible  validator  is  assigned  to  a  shard  based  on an  algorithm  that  keeps  the  nodes  evenly  distributed  across shards,  depending  on  the  tree  level.  Each  shard  contains  a randomly  selected  consensus  group.  Any  block  proposer  is responsible  to  aggregate  transactions  into  a  new  block.  The validators  are  responsible  to  either  reject,  or  approve  the proposed block, thereby validating it and committing it to the blockchain.</source>
        <target>De plus, le réseau est divisé en unités plus petites appelées fragments. Un valideur éligible est attribué à un fragmentsur la base d'un algorithme qui maintient les nœuds uniformément répartis à travers les fragment, en fonction du niveau dans l'arbre. Chaque shard contient un groupe de consensus choisi au hasard. Quiconque propose un bloc est responsable de l'agrégation des transactions dans un nouveau bloc. Les validateurs sont chargés soit de rejeter, soit d'approuver le bloc proposé, de sorte à le valider et à l’inscrire définitivement dans la blockchain.</target>
      </trans-unit>
      <trans-unit id="42" resname="0838fbcba7d6cf1695054ae1b798af7e">
        <source>2  Intrinsic token</source>
        <target>2 Jeton intrinsèque</target>
      </trans-unit>
      <trans-unit id="43" resname="132039842247295363ac2811eb69bdef">
        <source>Elrond  grants  access  to  the  usage  of  its  network  through intrinsic  utility  tokens  called  Elronds,  in  short  ERDs.  All costs for processing transactions, running smart contracts and rewards for various contributions to the network will be paid in ERDs. References to fees, payments or balances are assumed to be in ERDs.</source>
        <target>La façon dont Elrond autorise l'accès pour l’utilisation de son réseau se fait par le biais de jetons d’utilité intrinsèque appelés Elronds, en abrégé ERD. Tous les coûts liés au traitement des transactions, à l'exécution des « smart contracts » et aux récompenses pour les diverses contributions au réseau seront payés en ERD. Les références aux frais, aux paiements ou aux soldes sont supposées être en ERD.</target>
      </trans-unit>
      <trans-unit id="44" resname="0ead192ccd2085abbcd3ceb05f60ff6d">
        <source>3  Threat model</source>
        <target>3. Modèle de menace</target>
      </trans-unit>
      <trans-unit id="45" resname="d088083f5c6cfe399856cbe4e9b3e747">
        <source>33Elrond  assumes  a  byzantine  adversarial  model,  where  at least  2 n+1  of  the  eligible  nodes  in  a  shard  are  honest.  The protocol permits the existence of adversaries that have stake or good rating, delay or send conflicting messages, compromise other  nodes,  have  bugs  or  collude  among  themselves,  but  as long as 2 n+1 of the eligible validators in a shard are honest/not compromised, the protocol can achieve consensus.</source>
        <target>Elrond s’appuie sur un modèle contradictoire byzantin, dans lequel au moins 2 n+1 des nœuds éligibles d'un shard sont honnêtes. Le protocole rend acceptable l'existence d'adversaires qui disposent d’un enjeu ou d’une bonne cote, qui puissent retarder ou envoyer des messages conflictuels, qui compromettent d'autres nœuds, qui présentent des bogues ou qui sont de connivence entre eux, mais tant que 2 n+1 des validateurs éligibles dans un shard sont honnêtes/non compromis, le protocole peut aboutir à un consensus.
</target>
      </trans-unit>
      <trans-unit id="46" resname="cdee9bf40a070d58d14dfa3bb61e0032">
        <source>3</source>
        <target>3</target>
      </trans-unit>
      <trans-unit id="47" resname="3cb3a4eb2ac80e2a10bef96ae7998e4c">
        <source>The  protocol  assumes  highly  adaptive  adversaries,  which however  cannot  adapt  faster  than  a  round’s  timeframe.  The computational  power  of  an  adversary  is  bounded,  therefore the cryptographic assumptions granted by the security level of the chosen primitives hold firmly within the complexity class of problems solvable by a Turing machine in polynomial time. The  network  of  honest  nodes  is  assumed  to  form  a  well connected graph and the propagation of their messages is done in a bounded time ∆.</source>
        <target>Le protocole présuppose que les adversaires sont hautement adaptables, sans pour autant pouvoir s'adapter plus rapidement que la durée d'un tour. La puissance de calcul d'un adversaire est limitée, c'est pourquoi les hypothèses cryptographiques consenties par le niveau de sécurité des primitives choisies sont prises fermement à l’intérieur de la classe de complexité des problèmes pouvant être résolus par une machine de Turing en temps polynomial. Le réseau des nœuds honnêtes est supposé former un graphe bien connecté et la propagation de leurs messages se fait dans un temps borné ∆.</target>
      </trans-unit>
      <trans-unit id="48" resname="6dd0dcc0eeb720f889b9906879d89771">
        <source>Attack vectors’ prevention</source>
        <target>Prévention des vecteurs d'attaque</target>
      </trans-unit>
      <trans-unit id="49" resname="1d6156dc46feb0dc1a41fb6892a062c4">
        <source>1)  Sybil attacks:  mitigated through the stake locking when joining  the  network.  This  way  the  generation  of  new identities has a cost equal to the minimum stake;</source>
        <target>1) Attaques Sybil : atténuées par le verrouillage de la mise en jeu au moment de rejoindre le réseau. Ainsi, la génération des nouvelles identités présente un coût égal à celui de l'enjeu minimal ;</target>
      </trans-unit>
      <trans-unit id="50" resname="1ec1c4135c9c9dbedab848e7781d784a">
        <source>2)  Nothing at stake:  removed through the need of multiple signatures, not just from proposer, and the stake slashing. The reward per block compared to the stake locked will discourage such behavior;</source>
        <target>2) Rien en jeu : supprimé de par le besoin en signatures multiples, en plus de celle du proposant, et de par la réduction de l'enjeu. Comparée à la récompense par bloc, l'enjeu verrouillé découragera de tels comportements ;</target>
      </trans-unit>
      <trans-unit id="51" resname="262e235dcf76074d83ba4741594aaee5">
        <source>3)  Long  range  attacks:   mitigated by our pruning mech- anism, the use of a randomly selected consensus group every  round  (and  not  just  a  single  proposer)  and  stake locking. On top of all these, our pBFT consensus algo- rithm ensures finality;</source>
        <target>3) Attaques longue distance : atténuées par notre mécanisme d'élagage, et par l'utilisation d'un groupe de consensus sélectionné au hasard à chaque tour (et pas uniquement un seul proposant) ainsi que par le verrouillage de l'enjeu. De plus, notre algorithme de consensus pBFT garantit l’irrévocabilité ;</target>
      </trans-unit>
      <trans-unit id="52" resname="4edd126b557a57cf3330274937c0728e">
        <source>4)  DDoS attacks:   the consensus group is randomly sam pled  every  round  (few  seconds);  the  small  time  frame making DDoS almost impossible.</source>
        <target>4) Les attaques DDoS : le groupe de consensus est échantillonné au hasard à chaque tour (quelques secondes) ; le faible délai rendant le DDoS presque impossible. </target>
      </trans-unit>
      <trans-unit id="53" resname="eb6dc27855ef421f7ffd956d97b058de">
        <source>Other  attack  vectors  we  have  taken  into  consideration  are: shard  takeover  attack,  transaction  censorship,  double  spend, bribery attacks, etc.</source>
        <target>Les autres vecteurs d'attaque que nous avons pris en considération sont : attaque par prise de contrôle des fragments, censure des transactions, doubles dépenses, attaques de corruption, etc.</target>
      </trans-unit>
      <trans-unit id="54" resname="a87029bce1f9407e3cede56e5179f1cc">
        <source>4  Chronology</source>
        <target>4 Chronologie</target>
      </trans-unit>
      <trans-unit id="55" resname="2e68c1532dde2778b3bbba81478ac234">
        <source>In  Elrond’s  network,  the  timeline  is  split  into  epochs  and rounds. The epochs have a fixed duration, set to one day (can be modified as the architecture evolves), at the end of which the shards reorganization and pruning is triggered. The epochs are further divided into rounds, lasting for a fixed timeframe. A new consensus group is randomly selected per shard in each round, that can commit a maximum of one block in the shard’s ledger.</source>
        <target>Dans le réseau d'Elrond, la chronologie est divisée en époques et en tours. Les époques ont une durée constante, fixée à un jour (peut être modifiée à mesure que l'architecture évoluera), à l'issue de laquelle la réorganisation et l'élagage des fragments sont déclenchés. Les époques sont ensuite divisées en tours, d'une durée fixe. Un nouveau groupe de consensus est sélectionné au hasard par fragment à chaque tour, qui peut valider au maximum un bloc dans le registre du fragment.</target>
      </trans-unit>
      <trans-unit id="56" resname="f38221de7fe7a90c5defae5c1fbf3afe">
        <source>New validators can join the network by locking their stake, as presented in chapter V.2 - Secure Proof of Stake. They are added to the unassigned node pool in the current epoch e, are assigned to the waiting list of a shard at the beginning of epoch e + 1,  but  can  only  become  eligible  validators  to  participate in consensus and get rewarded in the next epoch e + 2.</source>
        <target>Les nouveaux valideurs peuvent rejoindre le réseau en verrouillant leur enjeu, comme présenté au chapitre V.2 - Preuve d'enjeu sécurisée. Ils sont ajoutés au pool de nœuds non attribués de l'époque courante e, sont inscrits sur la liste d'attente d’un fragment au début de l'époque e + 1, mais ne peuvent devenir des valideurs éligibles pour participer au consensus et être récompensés, uniquement à l'époque e + 2 suivante.</target>
      </trans-unit>
      <trans-unit id="57" resname="58b1a1d21dd1137212e0ff93a6ad224d">
        <source>The timeline aspects are further detailed in section IX.1.</source>
        <target>Les aspects relatifs à la chronologie sont détaillés dans la section IX.1.</target>
      </trans-unit>
      <trans-unit id="58" resname="d12a8f0d9cb3066588e42a98f6cdae4c">
        <source>III  Related Work</source>
        <target>II Travaux connexes</target>
      </trans-unit>
      <trans-unit id="59" resname="f24d3e7d00385ab1cd9d927d96dfe34a">
        <source>Elrond  was  designed  upon  and  inspired  by  the  ideas  from Ethereum  [6],  Omniledger  [7],  Zilliqa  [8],  Algorand  [3]  and ChainSpace  [9].  Our  architecture  goes  beyond  state  of  the art  and  can  be  seen  as  an  augmentation  of  the  existing models, improving the performance while focusing to achieve a  better  nash  equilibrium  state  between  security,  scalability and decentralization.</source>
        <target>Elrond a été conçu et inspiré par les idées d'Ethereum [6], Omniledger [7], Zilliqa [8], Algorand [3] et ChainSpace [9]. Notre architecture va au-delà de l'état de l'art et peut être considérée comme une augmentation des modèles existants, améliorant les performances tout en se concentrant sur un meilleur équilibre entre sécurité, évolutivité et décentralisation.</target>
      </trans-unit>
      <trans-unit id="60" resname="f83dcccc858fa2a0f1724bdd04344c30">
        <source>1  Ethereum</source>
        <target>1 Ethereum</target>
      </trans-unit>
      <trans-unit id="61" resname="2ea81e16d15a4afb4a7db43115189d9a">
        <source>Much  of  Ethereum’s  [6]  success  can  be  attributed  to  the introduction  of  its  decentralized  applications  layer  through EVM  [10],  Solidity  [11]  and  Web3j  [12].  While  Dapps  have been  one  of  the  core  features  of  ethereum,  scalability  has proved  a  pressing  limitation.  Considerable  research  has  been put  into  solving  this  problem,  however  results  have  been negligible up to this point. Still, few promising improvements are being proposed: Casper [13] prepares an update that will replace  the  current  Proof  of  Work  (PoW)  consensus  with  a Proof  of  Stake  (PoS),  while  Plasma  based  sidechains  and sharding are expected to become available in the near future, alleviating  Ethereum’s  scalability  problem  at  least  partially [14].</source>
        <target>Une grande partie du succès d'Ethereum [6] peut être attribuée à l'introduction de sa couche d'applications décentralisées par le biais d'EVM [10], Solidity [11] et Web3j [12]. Si les Dapps ont été l'une des caractéristiques essentielles d'Ethereum, l'extensibilité s'est avérée une limitation pressante. Des recherches considérables ont été menées pour résoudre ce problème, mais les résultats ont été négligeables jusqu'à présent. Pour autant, peu d'améliorations prometteuses ont été proposées : Casper [13] prépare une mise à jour qui remplacera le consensus actuel concernant la preuve de travail (proof of work) par une preuve d'enjeu (proof of stake), tandis que les chaînes latérales et les fragments à base de plasma devraient être disponibles dans un avenir proche, ce qui atténuera au moins partiellement le problème d'extensibilité d'Ethereum [14]. </target>
      </trans-unit>
      <trans-unit id="62" resname="b14a8f472193c1a0546f39a390d305fd">
        <source>Compared to Ethereum, Elrond eliminates both energy and computational waste from PoW algorithms by implementing a SPoS consensus while using transaction processing parallelism through sharding.</source>
        <target>Comparé à Ethereum, Elrond élimine les gaspilliages énergétiques et informatiques des algorithmes de PoW en mettant en œuvre un consensus SPoS tout en utilisant le parallélisme du traitement des transactions par fragments. </target>
      </trans-unit>
      <trans-unit id="63" resname="a137491e3a8f2cc62575d92b8efc5531">
        <source>2  Omniledger</source>
        <target>2 Ominiledger</target>
      </trans-unit>
      <trans-unit id="64" resname="5170aa75360d52aa65c5ace9c39aef04">
        <source>Omniledger [7] proposes a novel scale-out distributed ledger that  preserves  long  term  security  under  permission-less  op eration.  It  ensures  security  and  correctness  by  using  a  bias- resistant public-randomness protocol for choosing large, statis tically representative shards that process transactions. To commit  transactions  atomically  across  shards,  Omniledger  introduces  Atomix,  an  efficient  cross-shard  commit  protocol.  </source>
        <target>Omniledger [7] propose un nouveau registre distribué scalable horizontalement qui préserve la sécurité à long terme dans le cadre d'une exploitation libre de permission. Il garantit la sécurité et l'exactitude en utilisant un protocole publique à caractère aléatoire résistant aux biais pour choisir les grands fragments statistiquement représentatifs qui traitent les transactions. Pour engager des transactions de manière atomique entre fragments, Omniledger présente Atomix, un protocole efficace .</target>
      </trans-unit>
      <trans-unit id="65" resname="77ce7d6d1a4059c485ae35a52dd5d416">
        <source>The concept  is  a  two-phase  client-driven  ”lock/unlock”  protocol that  ensures  that  nodes  can  either  fully  commit  a  transaction across shards, or obtain ”rejection proofs” to abort and unlock the  state  affected  by  partially  completed  transactions.  Omniledger  also  optimizes  performance  via  parallel  intra-shard transaction  processing, ledger  pruning  via collectively-signed state  blocks,  and  low-latency  ”trust-but-verify”  validation  for low-value transactions. The consensus used in Omniledger is a BFT variation, named ByzCoinX, that increases performance and robustness against DoS attacks.</source>
        <target>Le concept est un protocole de &quot;verrouillage/déverrouillage&quot; à deux phases, piloté par le client, qui garantit que les nœuds peuvent, soit engager complètement une transaction sur des fragments, soit obtenir des &quot;preuves de rejet&quot; pour interrompre et déverrouiller l'état affecté par des transactions partiellement achevées. Omniledger optimise également les performances grâce au traitement parallèle des transactions intra-fragments, à l'élagage du grand livre par le biais de blocs d'état signés collectivement et à la validation à faible latence &quot;faire confiance mais vérifier&quot; pour les transactions de faible valeur. Le consensus utilisé dans Omniledger est une variante de BFT, appelée ByzCoinX, qui augmente les performances et la robustesse contre les attaques de déni de service.</target>
      </trans-unit>
      <trans-unit id="66" resname="41237d7b012602e5eac7fdb01e17696c">
        <source>Compared to Omniledger, Elrond has an adaptive approach on state sharding, a faster random selection of the consensus group  and  an  improved  security  by  replacing  the  validators’ set after every round (a few seconds) not after every epoch (1 day).</source>
        <target>Par rapport à Omniledger, Elrond a une approche adaptative du partage d'État, une sélection aléatoire plus rapide du groupe de consensus et une sécurité améliorée en remplaçant l'ensemble des validateurs après chaque tour (quelques secondes) et non après chaque époque (1 jour).</target>
      </trans-unit>
      <trans-unit id="67" resname="67e6c865ee91487d1e928f36ea3ca915">
        <source>3  Zilliqa</source>
        <target>3 Zilliqa</target>
      </trans-unit>
      <trans-unit id="68" resname="a521d8bfa42701fe1bc7700d7bd68bf8">
        <source>Zilliqa [8] is the first transaction-sharding architecture that allows the mining network to process transactions in parallel and reach a high throughput by dividing the mining network into shards. Specifically, its design allows a higher transaction rate  as  more  nodes  are  joining  the  network.  The  key  is to  ensure  that  shards  process  different  transactions,  with  no overlaps and therefore no double-spending. Zilliqa uses pBFT [15] for consensus and PoW to establish identities and prevent Sybil attacks.</source>
        <target>Zilliqa [8] est la première architecture de partitionnement des transactions permettant au réseau minier de traiter les transactions en parallèle et d'atteindre un débit élevé en divisant le réseau minier en fragments. Plus précisément, sa conception permet un taux de transaction plus élevé à mesure que de nouveaux nœuds rejoignent le réseau. L'essentiel est de veiller à ce que les fragments traitent des transactions différentes, sans chevauchement et donc sans double dépense. Zilliqa utilise le pBFT [15] pour le consensus et le PoW pour établir les identités et prévenir les attaques de type Sybil.</target>
      </trans-unit>
      <trans-unit id="69" resname="40ba83357271e4d2797fe90ee19115b4">
        <source>Compared  to  Zilliqa,  Elrond  pushes  the  limits  of  sharding by using not only transaction sharding but also state sharding. Elrond  completely  eliminates  the  PoW  mechanism  and  uses SPoS for consensus. Both architectures are building their own smart contract engine, but Elrond aims not only for EVM compliance, so that SC written for Ethereum will run seamlessly on our VM, but also aims to achieve interoperability between blockchains.</source>
        <target>Par rapport à Zilliqa, Elrond repousse les limites du partitionnement en utilisant, non seulement le partitionnement de transaction, mais aussi le partitionnement d'État. Elrond élimine complètement le mécanisme du PoW et utilise le SPoS pour le consensus. Les deux architectures construisent leur propre moteur de contrat intelligent, mais Elrond vise non seulement la conformité EVM, de sorte que le SC écrit pour Ethereum fonctionne de manière transparente sur notre VM, mais vise également à réaliser l'interopérabilité entre les blockchains.</target>
      </trans-unit>
      <trans-unit id="70" resname="4e55779d8c1c654bb5cbf6c7ffa5f604">
        <source>4  Algorand</source>
        <target>4 Algorand</target>
      </trans-unit>
      <trans-unit id="71" resname="ffd238d39f9583d9d357edfa4690a1bd">
        <source>Algorand  [3]  proposes  a  public  ledger  that  keeps  the  convenience  and  efficiency  of  centralized  systems,  without  the inefficiencies and weaknesses of current decentralized implementations.  The  leader  and  the  set  of  verifiers  are  randomly chosen,  based  on  their  signature  applied  to  the  last  block’s quantity  value.  The  selections  are  immune  to  manipulations and unpredictable until the last moment. The consensus relies on a novel message-passing Byzantine Agreement that enables the community and the protocol to evolve without hard forks. Compared   to   Algorand,   Elrond   doesn’t   have   a   single blockchain, instead it increases transaction’s throughput using sharding. Elrond also improves on Algorand’s idea of random selection by reducing the selection time of the consensus group from over 12 seconds to less than a second, but assumes that</source>
        <target>Algorand [3] propose un grand livre public qui conserve la commodité et l'efficacité des systèmes centralisés, sans les inefficacités et les faiblesses des mises en œuvre décentralisées actuelles. Le chef et l'ensemble des vérificateurs sont choisis au hasard, en fonction de leur signature appliquée à la valeur de la quantité du dernier bloc. Les sélectionnés sont à l'abri des manipulations et imprévus jusqu'au dernier moment. Le consensus repose sur un nouvel accord byzantin de transmission de messages qui permet à la communauté et au protocole d'évoluer sans bifurquer. Par rapport à Algorand, Elrond n'a pas de blockchain unique, mais augmente le débit des transactions grâce aux fragments. Elrond améliore également l'idée de sélection aléatoire d'Algorand en réduisant le temps de sélection du groupe de consensus de plus de 12 secondes à moins d'une seconde, mais suppose que</target>
      </trans-unit>
      <trans-unit id="72" resname="0c68ffe86052edb9b4bf69b4b9ae62c1">
        <source>the adversaries cannot adapt within a round.</source>
        <target>les adversaires ne peuvent pas s'adapter au cours d'un tour.</target>
      </trans-unit>
      <trans-unit id="73" resname="c90b640b34168875fbf7c58676feb37a">
        <source>Compared  to  Chainspace,  where  the  TPS  decreases  with each  node  added  in  a  shard,  Elrond’s  approach  is  not  influenced  by  the  number  of  nodes  in  a  shard,  because  the  consensus group has a fixed size. A strong point for Chainspace is  the  approach  for  language  agnostic  smart  contracts,  while Elrond  focuses  on  building  an  abstraction  layer  for  EVM compliance. Both  projects  use  different  approaches  for  state sharding  to  enhance  performance.  However,  Elrond  goes  a step  further  by  anticipating  the  blockchain  size  problem  in high  throughput  architectures  and  uses  an  efficient  pruning mechanism.  Moreover,  Elrond  exhibits  a  higher  resistance to  sudden  changes  in  node  population  and  malicious  shard takeover  by  introducing  shard  redundancy,  a  new  feature  for sharded blockchains.</source>
        <target>Par rapport à Chainspace, où le TPS diminue avec chaque nœud ajouté dans une shard, l'approche d'Elrond n'est pas influencée par le nombre de nœuds dans celle-ci, car le groupe de consensus a une taille fixe. Un point fort de Chainspace est l'approche des contrats intelligents agnostiques au langage, tandis qu'Elrond se concentre sur la construction d'une couche d'abstraction pour la conformité EVM. Les deux projets utilisent des approches différentes pour les fragments d'État afin d'améliorer les performances. Cependant, Elrond va plus loin en anticipant le problème de la taille des blockchains dans les architectures à haut débit et utilise un mécanisme d'élagage efficace. En outre, Elrond présente une plus grande résistance aux changements soudains de la population de nœuds et à la prise de contrôle malveillante des shards en introduisant la redondance des fragment, une nouvelle fonctionnalité pour les chaînes de blocs fragmentées.</target>
      </trans-unit>
      <trans-unit id="74" resname="4cbd70b138042bec5a35ee643064d843">
        <source>IV  Scalability via Adaptive State Sharding</source>
        <target>IV Scalabilité via partitionnement d’état adaptatif</target>
      </trans-unit>
      <trans-unit id="75" resname="92e077c16d0f3333fb8e2934167d3317">
        <source>1  Why sharding</source>
        <target>1 Pourquoi partitionner horizontalement ?</target>
      </trans-unit>
      <trans-unit id="76" resname="5bd4c1c1276e5e6f790c4546439872f5">
        <source>Sharding was first used in databases and is a method for distributing data across multiple machines. This scaling technique can be used in blockchains to partition states and transaction processing, so that each node would process only a fraction of all transactions in parallel with other nodes. As long as there is  a  sufficient  number  of  nodes  verifying  each  transaction  so that  the  system  maintains  high  reliability  and  security,  then splitting a blockchain into shards will allow it to process many transactions in parallel, and thus greatly improving transaction throughput  and  efficiency.  Sharding  promises  to  increase  the throughput  as  the  validator  network  expands,  a  property  that is referred to as horizontal scaling.</source>
        <target>A l’origine, le partitionnement était utilisé dans les bases de données en tant que méthode de distribution des données entre plusieurs machines. Cette technique de passage à l'échelle peut être appliquée à la blockchain pour partitionner les états et le traitement des transactions, de sorte à ce que chaque nœud ne traite qu'une fraction de toutes les transactions en parallèle avec les autres nœuds. Tant qu'il y a un nombre de nœuds suffisant, et qui vérifient chaque transaction afin que le système maintienne une fiabilité et une sécurité élevées, dans ces conditions, le découpage d'une blockchain donnée, en partitions horizontales lui permettra de traiter de nombreuses transactions en parallèle, et donc d'améliorer considérablement le débit des transactions ainsi que l’efficacité des traitements. La promesse du partitionnement est de pouvoir augmenter le débit au fur et à mesure que le réseau de valideurs s'étend, c’est une propriété designée sous le nom de scalabilité horizontale..</target>
      </trans-unit>
      <trans-unit id="77" resname="d4da2ce6d5180ffe62a68228f78ca8a4">
        <source>2  Sharding types</source>
        <target>2 Types de sharding</target>
      </trans-unit>
      <trans-unit id="78" resname="22ad0e9467a6882efcb1fd0aad50b664">
        <source>A  comprehensive  and  thorough  introduction  [16]  emphasizes  the  three  main  types  of  sharding:  network  sharding, transaction  sharding  and  state  sharding.  Network  sharding handles  the  way  the  nodes  are  grouped  into  shards  and  can be  used  to  optimize  communication,  as  message  propagation inside  a  shard  can  be  done  much  faster  than  propagation to  the  entire  network.  This  is  the  first  challenge  in  every sharding  approach  and  the  mechanism  that  maps  nodes  to shards has to take into consideration the possible attacks from an attacker that gains control over a specific shard. Transaction sharding  handles  the  way  the  transactions  are  mapped  to  the shards  where  they  will  be  processed.  In  an  account-based system, the transactions could be assigned to shards based on the  sender’s  address.  State  sharding  is  the  most  challenging approach.  In  contrast  to  the  previously  described  sharding mechanisms,  where  all  nodes  store  the  entire  state,  in  state- sharded  blockchains,  each  shard  maintains  only  a  portion  of the  state.  Every  transaction  handling  accounts  that  are  in different shards, would need to exchange messages and update states  in  different  shards. In  order  to  increase  resiliency  to malicious attacks, the nodes in the shards have to be reshuffled from  time  to  time. However,  moving  nodes  between  shards introduces  synchronization  overheads,  that  is,  the  time  taken for the newly added nodes to download the latest state. Thus,it is imperative that only a subset of all nodes should be redistributed during each epoch, to prevent down times during the synchronization process.</source>
        <target>Une introduction complète et détaillée [16] met l'accent sur les trois principaux types sharding : sharding de réseau, sharding de transaction, et sharding d’état. Le sharding de réseau gère la façon dont les nœuds sont regroupés en shard et peut être utilisé pour optimiser la communication, car la propagation des messages à l'intérieur d'un shard peut se faire beaucoup plus rapidement que la propagation à l'ensemble du réseau. C'est le premier défi dans chaque approche de sharding et le mécanisme qui fait correspondre les nœuds aux shard doit prendre en considération les attaques possibles d'un attaquant qui prend le contrôle d'un shard spécifique. Le sharding de transaction gère la manière dont les transactions sont mises en correspondance avec les shards où elles seront traitées. Dans un système basé sur des comptes, les transactions pourraient être attribuées à des shards en fonction de l'adresse de l'expéditeur. L'approche la plus difficile est celle du sharding d’état. Contrairement aux mécanismes de découpage en shards décrits précédemment, où tous les nœuds stockent l'état complet, dans les blockchains découpées horizontalement en shards d’état, chaque shard ne maintient qu'une partie de l’état. Chaque transaction traitant des comptes qui se trouvent dans des shards différente, devrait échanger des messages et mettre à jour les états dans des shards différents. Afin d'accroître la résilience aux attaques malveillantes, les nœuds des shards doivent être re-mélangés de temps en temps. Cependant, le déplacement des nœuds entre les shards introduit des coûts de synchronisation, qui correspond au temps nécessaire pour que les nœuds nouvellement ajoutés puissent télécharger le dernier état. Ainsi, il est impératif que seul un sous-ensemble de tous les nœuds soit redistribué à chaque époque, pour éviter les temps d'arrêt pendant le processus de synchronisation.</target>
      </trans-unit>
      <trans-unit id="79" resname="b6b0d3df880b43818b9d4658818b77df">
        <source>3  Sharding directions</source>
        <target>3 Les tendances du sharding</target>
      </trans-unit>
      <trans-unit id="80" resname="e88b4b894b6bfa4bbf5ead0cc99b9049">
        <source>Some sharding proposals attempt to only shard transactions [8]  or  only  shard  state  [17],  which  increases  transaction’s throughput, either by forcing every node to store lots of state data  or  to  be  a  supercomputer  [2].  Still,  more  recently,  at least one claim has been made about successfully performing both transaction and state sharding, without compromising on storage or processing power [13].</source>
        <target>Certaines propositions sharding tentent de mettre en oeuvre uniquement du sharding de transactions [8] ou uniquement du sharding d'état  [17], ce qui augmente le débit de la transaction, soit en forçant chaque nœud à stocker beaucoup de données d'état, soit en étant un superordinateur [2]. Pourtant, plus récemment, au moins une revendication a été faite quant à la réussite de sharding à la fois de transaction et d'état, sans compromettre la puissance de stockage ou de traitement [13].</target>
      </trans-unit>
      <trans-unit id="81" resname="fc381589ed61e441f62f59f3e76d6d2f">
        <source>But  sharding  introduces  some  new  challenges  like:  single- shard takeover attack, cross-shard communication, data availability  and  the  need  of  an  abstraction  layer  that  hides  the shards.   However,   conditional   on   the   fact   that   the   above problems  are  addressed  correctly,  state  sharding  brings  considerable  overall  improvements:  transaction  throughput  will increase  significantly  due  to  parallel  transaction  processing and transaction fees will be considerably reduced. Two main criterias  widely  considered  to  be  obstacles  transforming  into advantages  and  incentives  for  mainstream  adoption  of  the blockchain technology.</source>
        <target>Mais le sharding pose de nouveaux défis, comme l'attaque par prise de contrôle d'un shard unique, la communication entre les shards, la disponibilité des données et la nécessité d'une couche d'abstraction qui cache les shards. Toutefois, sous réserve que les problèmes susmentionnés soient correctement traités, le sharding d’état apporte des améliorations globales considérables : le débit des transactions augmente de manière significative en raison du traitement parallèle des transactions et les frais de transaction seront considérablement réduits. Deux principaux critères largement considérés comme des obstacles se transformant en autant d’avantages et d’incitations à l'adoption généralisée de la technologie blockchain.</target>
      </trans-unit>
      <trans-unit id="82" resname="14eeb3b6b98bdbcb2e9ddde7d2b50c46">
        <source>4  Elrond sharding approach</source>
        <target>4 Approche d'Elrond sur le sharding</target>
      </trans-unit>
      <trans-unit id="83" resname="6c44dcc1dc46ad2643b59ef3dbe67943">
        <source>While  dealing  with  the  complexity  of  combining  network, transaction and state sharding, Elrond’s approach was designed with the following goals in mind:</source>
        <target>Tout en faisant face à la complexité de la combinaison du sharding de transaction avec le sharding d’état, l'approche d'Elrond a été conçue avec les objectifs suivants en tête :</target>
      </trans-unit>
      <trans-unit id="84" resname="0473ce215c4dc2011cf8ced0a6e0ac66">
        <source>1)  Scalability  without  affecting  availability:  Increasing or  decreasing  the  number  of  shards  should  affect  a negligibly small vicinity of nodes without causing down- times, or minimizing them while updating states;</source>
        <target>1) Scalabilité sans affecter la disponibilité : Augmenter ou diminuer le nombre de partitions devrait affecter de manière négligeable un petit nombre des nœuds qui sont à proximité, sans provoquer de temps d'arrêt, ou de les minimiser tout en actualisant les états ;</target>
      </trans-unit>
      <trans-unit id="85" resname="8cc975af702ec92b5705634acb9a5ae4">
        <source>2)  Dispatching  and  instant  traceability: Finding out the destination shard of a transaction should be deterministic, trivial to calculate, eliminating the need for communication rounds;</source>
        <target>2) Expédition et traçabilité instantanée : La découverte du shard de destination d'une transaction doit être déterministe, triviale à calculer, éliminant le besoin de tours de communication ;</target>
      </trans-unit>
      <trans-unit id="86" resname="e2370581e04c13bd62c28cd36cc6d059">
        <source>3)  Efficiency  and  adaptability:  The  shards  should  be  as balanced as possible at any given time.</source>
        <target>3) Efficacité et adaptabilité : Les partitions doivent être aussi équilibrées que possible à chaque instant. </target>
      </trans-unit>
      <trans-unit id="87" resname="de3fe85e9dfdfbd044376155370e980b">
        <source>Method Description</source>
        <target>Description de la méthode</target>
      </trans-unit>
      <trans-unit id="88" resname="7d7db20830564adfe461fd0c6a677dea">
        <source>To  calculate  an  optimum  number  of  shards  Nsh   in  epoch ei+1   (Nsh,i+1),  we  have  defined  one  threshold  coefficient for  the  number  of  transactions  in  a  block,  θT X .  Variable optN   represents  the  optimal  number  of  nodes  in  a  shard, sh  is a positive number and represents the number of nodes a  shard  can  vary  by.  totalNi   is  the  total  number  of  nodes (eligible validators, nodes in the waiting lists and newly added nodes  in  the  node  pool)  on  all  shards  in  epoch  ei,  while NT XB,i  is  the  average  number  of  transactions  in  a  block  on all  shards  in  epoch  ei.  Nsh,0   will  be  considered  as  1.</source>
        <target>Pour calculer un nombre optimal de shards Nsh dans l'époque ei+1 (Nsh;i+1), nous avons défini un coefficient de seuil pour le nombre de transactions dans un bloc, TX. La variable optN représente le nombre optimal de nœuds dans un shard, sh est un nombre positif et représente la fourchette de variation du nombre de nœuds d'un shard. totalNi est le nombre total de nœuds (validateurs éligibles, nœuds dans les listes d'attente et nouveaux nœuds dans le pool de nœuds) sur toutes les shards de l'époque ei, tandis que NTXB;i est le nombre moyen de transactions dans un bloc sur tous les shards de l'époque ei. Nsh;0 sera considéré comme valant 1.</target>
      </trans-unit>
      <trans-unit id="89" resname="5ec99847414837e4e47adb790d534097">
        <source>The total number of shards Nsh,i+1  will change if the number of nodes  totalNi   in  the  network  changes  and  if  the  blockchain utilization needs it: if the number of nodes increases above a threshold nSplit  from one  epoch to another  and the  average number of transactions per block is greater than the threshold subset  of  all  nodes  should  be number  of  transactions  per  block  NT XB,i   &gt;  θT X   or  if  the number  of  nodes  decreases  below  a  threshold  nMerge  as shown in function ComputeShardsN.</source>
        <target>Le nombre total de shards Nsh;i+1 changera si le nombre de nœuds totalNi du réseau change et si l’utilisation de la blockchain en a besoin : si le nombre de nœuds augmente au-delà d'un seuil nSplit d'une époque à l'autre et que le nombre moyen de transactions par bloc est supérieur au seuil de transactions par bloc NTXB;i &gt; TX ou si le le nombre de nœuds diminue en dessous d'un seuil nMerge comme indiqué dans la fonction ComputeShardsN.</target>
      </trans-unit>
      <trans-unit id="90" resname="6d667bd223426ee9834308ec9ececaac">
        <source>From  one  epoch  to  another,  there  is  a  probability  that  the</source>
        <target>D'une époque à l'autre, il y a une probabilité que le </target>
      </trans-unit>
      <trans-unit id="91" resname="029cdfd856758a84e75e928b1c0a5063">
        <source>number of active nodes changes. If this aspect influences the number of shards, anyone can calculate the two masks m1  and m2, used in transaction dispatching.</source>
        <target>nombre de shards actifs change. Si cet aspect influence le nombre de shards, n'importe qui peut calculer les deux masques m1 et m2, utilisés dans la distribution des transactions.</target>
      </trans-unit>
      <trans-unit id="92" resname="7defac7e8418fc7fba67f3c933e6f510">
        <source>As  the  main  goal  is  to  increase  the  throughput  beyond thousands of transactions per second and to diminish the cross- shard  communication,  Elrond  proposes  a  dispatching  mechanism  which  determines  automatically  the  shards  involved  in the current transaction and routes the transaction accordingly. The dispatcher will take into consideration the account address (addr)  of  the  transaction  sender/receiver.  The  result  is  the number of the shard (shard) the transaction will be dispatched to.</source>
        <target>L'objectif principal étant d'augmenter le débit au-delà des milliers de transactions par seconde et de diminuer la communication entre les shards, Elrond propose un mécanisme de répartition qui détermine automatiquement les partitions impliqués dans la transaction en cours et achemine la transaction en conséquence. L'expéditeur prendra en considération l'adresse de compte (addr) de l'expéditeur/récepteur de la transaction. Le résultat est le numéro de shard (shard)  auquel la transaction sera envoyée.</target>
      </trans-unit>
      <trans-unit id="93" resname="3279246e6b130042d11c043de689ccfd">
        <source>The  entire  sharding  scheme  is  based  on  a  binary  tree structure  that  distributes  the  account  addresses,  favors  the scalability and deals with the state transitions. A representation of the tree can be seen in Fig. 2.</source>
        <target>L'ensemble du système de sharding est basé sur un arbre binaire qui distribue les adresses des comptes, favorise la scalabilité et traite les transitions d'état. Une représentation de l'arbre est visible sur la figure 2.</target>
      </trans-unit>
      <trans-unit id="94" resname="b47870b5aa6337e1244067c2b53bd220">
        <source>The  presented  tree  structure  is  merely  a  logical  representation  of  the  account  address  space  used  for  a  deterministic mapping;  e.g.  shard  allocation,  sibling  computation  etc.  The leaves  of  the  binary  tree  represent  the  shards  with  their  ID number. Starting from root (node/shard 0), if there is only one shard/leaf  (a),  all  account  addresses  are  mapped  to  this  one and  all  transactions  will  be  executed  here.  Further  on,  if  the formula  for  Nsh   dictates  the  necessity  of  2  shards  (b),  the address space will be split in equal parts, according to the last bits in the address.</source>
        <target>L'arborescence présentée n'est qu'une représentation logique de l'espace d'adresse du compte utilisé pour une mise en correspondance déterministe ; par exemple, l'attribution des shards, le calcul des noeuds frères, etc. Les feuilles de l'arbre binaire représentent les shards avec leur numéro ID. En partant de la racine (noeud/partition 0), s'il n'y a qu'une seule partition/feuille (a), toutes les adresses de compte sont associées à celui-ci et toutes les transactions seront exécutées là. Plus loin, si la formule de Nsh impose la nécessité de 2 shards (b), l'espace d'adresse sera divisé en parties égales, en fonction des derniers bits de l'adresse.</target>
      </trans-unit>
      <trans-unit id="95" resname="28d3d28aeabc853f2e9b6e2e9fcfee49">
        <source>Sometimes, the tree can also become unbalanced (c) if Nsh</source>
        <target>Parfois, l'arbre peut aussi se déséquilibrer (c) si Nsh </target>
      </trans-unit>
      <trans-unit id="96" resname="292a7aa8e9d7af5a485b6d2f308ecccc">
        <source>is  not  a  power  of  2.  This  case  only  affects  the  leaves  on  the last level. The structure will become balanced again when the number of shards reaches a power of 2.</source>
        <target>n'est pas une puissance de 2. Ce cas n'affecte que les feuilles du 6ème niveau. La structure redeviendra équilibrée lorsque le nombre de shards atteindra de nouveau une puissance de 2.</target>
      </trans-unit>
      <trans-unit id="97" resname="5f3545608a351ce0fc45088f4f7bde7e">
        <source>Fig. 2: Example of a sharding tree structure</source>
        <target>Fig. 2 : Exemple d'une structure arborescente de partition</target>
      </trans-unit>
      <trans-unit id="98" resname="ea56f839a2f82206f80813a06bdd7b0e">
        <source>The unbalancing of the binary tree causes the shards located in  the  lowest  level  to  have  half  the  address  space  of  nodes of  a  shard  located  one  level  higher,  so  it  can  be  argued  that the  active  nodes  allocated  to  these  shards  will  have  a  lower fee  income  -  block  rewards  are  not  affected.  However,  this problem  is  solved  by  having  a  third  of  each  shard  nodes redistributed randomly each epoch (detailed in the Chronology section) and having a balanced distribution of nodes according to the tree level.</source>
        <target>Lorsque l'arbre binaire n’est plus équilibré, ceci implique que les shards situés au niveau le plus bas occupent la moitié de l'espace d'adressage des nœuds d'un shard située au niveau du dessus, on peut donc affirmer que les nœuds actifs attribués à ces shards percevront des revenus plus faibles - les récompenses de bloc ne sont pas affectées. Toutefois, ce problème est résolu en distribuant un tiers de chaque nœud de shard de façon aléatoire à travers chaque époque (détaillée dans la Chronologie ) et présentant une répartition équilibrée des nœuds selon le niveau de l'arbre.</target>
      </trans-unit>
      <trans-unit id="99" resname="8beedf18491eca630c42df69c77d27d1">
        <source>Looking  at  the  tree,  starting  from  any  leaf  and  going through branches towards the root, the encoding from branches represents  the  last  n  bits  of  the  account  addresses  that  will have their associated originating transactions processed by that leaf/shard.  Going  the  other  way  around,  from  root  to  leaf, the  information  is  related  to  the  evolution  of  the  structure, sibling shards, the parent shard from where they split. Using this hierarchy, the shard that will split when Nsh  increases or the shards that will merge when Nsh  decreases can easily be calculated. The entire state sharding mechanism benefits from this structure by always keeping the address and the associated state within the same shard.</source>
        <target>En regardant l'arbre, à partir de n'importe quelle feuille et en progressant le long des branches en direction de la racine, l'encodage des branches correspond aux n derniers bits des adresses de compte qui feront traiter, par cette feuille/shard, leurs transactions d'origine associées. En allant dans l'autre sens, de la racine vers la feuille, l'information est liée au développement de la structure, shards frères, du shard parent d'où ils se séparent. À l'aide de cette hiérarchie, le shard qui se divise lorsque Nsh augmente ou les shards qui fusionnent lorsque Nsh diminue peuvent être facilement calculés. L'ensemble du mécanisme de sharding d'état bénéficie de cette structure en gardant toujours l'adresse et l'état associé dans le même shard..</target>
      </trans-unit>
      <trans-unit id="100" resname="83f651dc03527adc9f6f46fd82260fa6">
        <source>Knowing Nsh, any node can follow the redistribution pro- cess  without  the  need  of  communication.  The  allocation  of ID’s  for  the  new  shards  is  incremental  and  reducing  the number  of  shards  involves  that  the  higher  numbered  shards will be removed. For example, when going from Nsh  to Nsh-1,  two  shards  will  be  merged,  the  shard  to  be  removed  is</source>
        <target>Connaissant Nsh, n'importe quel nœud peut suivre le processus de redistribution sans avoir besoin de communication. L'allocation des ID pour les nouveaux shards est incrémentale et la réduction du nombre de shards implique que les shards les plus élevés seront supprimés. Par exemple, lorsque vous allez de Nsh à Nsh-1, deux shards seront fusionnés, le shards à supprimer est</target>
      </trans-unit>
      <trans-unit id="101" resname="ac29e9c689b4a6ab3a63dc1ccb861e9e">
        <source>the  highest numbered  shard  (shmerge=Nsh-1). Finding  the shard  number  that  shmerge   will  be  merged  with  is  trivial. According  to  the  tree  structure,  the  resulting  shard  has  the sibling’s number:</source>
        <target>le shard numéroté le plus élevé (Shmerge=NSH-1). Trouver le numéro de shard avec lequel shmerge sera fusionné est trivial. Selon la structure de l'arbre, le shard résultant aura le numéro du frère :</target>
      </trans-unit>
      <trans-unit id="102" resname="747939842f9e6eef50975f7c8e93f3b5">
        <source>For  shard  redundancy,  traceability  of  the  state  transitions and fast scaling, it is important to determine the sibling  and parent of a generic shard with number p:</source>
        <target>Pour la redondance des shards, la traçabilité des transitions d'état et le passage à l'échelle rapide, il est important de déterminer le frère et le parent d'un shard générique avec le nombre p :</target>
      </trans-unit>
      <trans-unit id="103" resname="4bce9497e432d09b773ae637d1a40a0d">
        <source>Shard redundancy</source>
        <target>redondance des shard</target>
      </trans-unit>
      <trans-unit id="104" resname="4cbfbba7abc7280a4d38fa22372bb4c8">
        <source>33On blockchain, state sharding is susceptible to shard failure when  there  is  an  insufficient  number  of  online  nodes  in  a shard  or  the  distribution  is  localized  geographically.  In  the unlikely  case  when  one  shard  fails  (either  the  shard  cannot be  contacted  -  all  nodes  are  offline,  or  consensus  cannot  be reached - more than  1   of nodes are not responding), there is a  high  risk  that  the  entire  architecture  relies  only  on  super- full  nodes  [2],  which  fully  download  every  block  of  every shard, fully verifying everything. As displayed in Fig. 3, our protocol has a protection mechanism that introduces a tradeoff in  the  state  holding  structure  by  enforcing  the  shards  from the  last  tree  level  to  also  hold  the  state  from  their  siblings. This  mechanism  reduces  the  communication  and  eliminates the bootstrapping when sibling shards are merging since they already have the data.</source>
        <target>33 Sur la blockchain, le partage d'état est exposé aux échecs de shards lorsqu'il y a un nombre insuffisant de nœuds en ligne dans un shard ou que la distribution est localisée géographiquement. Dans le cas peu probable où un shard échoue (soit le shard ne peut pas être contacté - tous les nœuds sont hors-lignes ou un consensus ne peut pas être atteint - plus d'un des nœuds ne répond pas), il y a un risque élevé que l'architecture entière ne repose que sur des nœuds super-pleins [2], qui téléchargent entièrement chaque bloc de chaque shard, vérifiant entièrement tout. Comme le montre la Fig. 3, notre protocole dispose d'un mécanisme de protection qui introduit un compromis dans la structure de maintien de l'état en imposant aux shards du dernier niveau de l'arbre de maintenir également l'état de leurs frères. Ce mécanisme réduit la communication et élimine le bootstrapping lorsque des shards frères fusionnent puisqu'ils ont déjà les données.</target>
      </trans-unit>
      <trans-unit id="105" resname="3d145f69e9e3004608d8317b9d6023e9">
        <source>Context switching</source>
        <target>Changement de contexte</target>
      </trans-unit>
      <trans-unit id="106" resname="3933b9607bb98634bf24aec2fba0a92f">
        <source>To preserve security in sharded public blockchains, context switching  becomes  crucial  [7].  This  refers  to  the  reallocation  of  the  active  nodes  between  shards  on  a  fixed  time interval  by  some  random  criteria.  In  Elrond’s  approach,  the context switching represents a security improvement, but also increases  the  complexity  required  to  maintain  consistency between  multiple  states.  The  state  transition  has  the  biggest footprint on performance since the movement of active nodes requires to resync the state, blockchain and transactions along- side  the  eligible  nodes  in  the  new  shard.</source>
        <target>Pour préserver la sécurité dans blockchains publiques appliquant le sharding, le changement de contexte devient crucial [7]. Cela fait référence à la réaffectation des nœuds actifs entre les shards sur un intervalle de temps fixe selon certains critères aléatoires. Dans l'approche d'Elrond, le changement de contexte apporte une amélioration de la sécurité, mais augmente également la complexité nécessaire pour maintenir la cohérence entre plusieurs états. La transition d'état laisse la plus grande empreinte sur les performances puisque le mouvement des nœuds actifs nécessite de resynchroniser l'état, la blockchain et les transactions en même temps que les nœuds éligibles dans le nouveau shard.</target>
      </trans-unit>
      <trans-unit id="107" resname="e188184d3bebcd778c0bda0d854901b2">
        <source>Fig. 3: Shard redundancy across epochs</source>
        <target>Fig. 3: Redondance des shards à travers les époques</target>
      </trans-unit>
      <trans-unit id="108" resname="be4318d679a1ebdbebce492cc0b80165">
        <source>At  the  start  of each  epoch,  in  order  to  maintain  liveness,  only  less  than  1 of these nodes will be uniformly re-distributed across shards. This mechanism is highly effective against forming malicious groups.</source>
        <target>Au début de chaque époque, afin de maintenir la viabilité, seul moins d'un de ces nœuds sera uniformément redistribué entre les shards. Ce mécanisme est très efficace contre la formation de groupes malveillants.</target>
      </trans-unit>
      <trans-unit id="109" resname="b0b26f255d410b2ffce8175af24f3449">
        <source>5  Notarization (Meta) chain</source>
        <target>5 Chaîne de notarisation (Meta)</target>
      </trans-unit>
      <trans-unit id="110" resname="2a0b8124dbbe02fbc4848231985d523d">
        <source>All  network  and  global  data  operations  (node  joining  the network,  node  leaving  the  network,  eligible  validator  lists computation,  nodes  assignment  to  the  shard’s  waiting  lists, consensus agreement on a block in a specific shard challenges for  invalid  blocks  will  be  notarized  in  the  metachain.  The metachain  consensus  is  run  by  a  different  shard  that  communicates  with  all  other  shards  and  facilitates  cross-shard operations. Every round of every epoch, the metachain receives block headers from the other shards and, if necessary, proofs for  the  challenges  of  the  invalid  blocks.  This  information will  be  aggregated  into  blocks  on  the  metachain  on  which consensus  has  to  be  run.  Once  the  blocks  are  validated  in the  consensus  group,  shards  can  request  information  about blocks, miniblocks (see chapter VII), eligible validators, nodes in  waiting  lists  etc.,  in  order  to  securely  process  cross-shard transactions. Further details about the cross-shard transaction execution, communication between shards and metachain will be presented in Chapter VII Cross-shard transaction processing.</source>
        <target>Toutes les opérations relatives au réseau et aux données globales (nœud rejoignant le réseau, nœud quittant le réseau, calcul des listes de validateurs éligibles, affectation des nœuds aux listes d'attente des shards, accord par consensus sur un bloc dans un shard spécifique, les contestations des blocs non valides) seront notariées dans la métachaîne. Le consensus de la métachaîne est géré par un shard différent qui communique avec tous les autres shard et facilite les opérations entre shards. À chaque tour de chaque époque, la métachaîne reçoit les en-têtes de bloc des autres shards et, si nécessaire, les preuves des contestations des blocs invalides. Ces informations seront regroupées en blocs sur la métachaîne sur lesquels un consensus doit être exécuté. Une fois les blocs validés dans le groupe de consensus, les shards peuvent demander des informations sur les blocs, les miniblocs (voir chapitre VII), les validateurs éligibles, les nœuds des listes d'attente, etc. afin de traiter en toute sécurité les transactions entre shards. De plus amples informations sur l'exécution des opérations croisées entre shards, la communication entre les shards et la métachaîne seront présentées au chapitre VII Traitement des transactions croisées entre shards.</target>
      </trans-unit>
      <trans-unit id="111" resname="47c55a2ed1fb1d5c29cd806737043a97">
        <source>V  Consensus via Secure Proof of Stake</source>
        <target>V Consensus par preuve d'enjeu sécurisée</target>
      </trans-unit>
      <trans-unit id="112" resname="ca64b36635349435cab76d3f472c26a9">
        <source>1  Consensus Analysis</source>
        <target>1 Analyse du consensus</target>
      </trans-unit>
      <trans-unit id="113" resname="0c086e3d79c8fd122680b9c714435500">
        <source>The  first  blockchain  consensus  algorithm  based  on  Proof of  Work  (PoW),  is  used  in  Bitcoin,  Ethereum  and  other blockchain platforms. In Proof of Work each node is required to solve a mathematical puzzle (hard to calculate but easy to verify). And the first node that finishes the puzzle will collect the  reward  [18].  Proof  of  Work  mechanisms  successfully prevent double-spending, DDoS and Sybil attacks at the cost of high energy consumption.</source>
        <target>Le premier algorithme de consensus de blockchain basé sur la Preuve de Travail (Proof of Work = PoW), est utilisé dans Bitcoin, Ethereum et d'autres plates-formes blockchain. Dans la Preuve de Travail, chaque nœud est nécessaire pour résoudre un puzzle mathématique (difficile à calculer mais facile à vérifier). Et le premier nœud qui termine le puzzle recueille la récompense [18]. Les mécanismes de Preuve de Travail permettent d'éviter les doubles dépenses, les attaques DDoS et Sybil au prix d'une consommation d'énergie élevée.</target>
      </trans-unit>
      <trans-unit id="114" resname="5bb51231b8db971336cd18d78d201b19">
        <source>Proof  of  Stake  (PoS)  is  a  novel  and  more  efficient  consensus mechanism proposed as an alternative to the intensive energy  and  computational  use  in  Proof  of  Work  consensus mechanisms. PoS can be found in many new architectures like Cardano [19] and Algorand [3] or can be used in next version of  Ethereum.  In  PoS  the  node  that  proposes  the  next  block is  selected  by  a  combination  of  stake  (wealth),  randomness and/or age. It mitigates the PoW energy problem but also puts two important issues on the table: the Nothing at Stake attack and a higher centralization risk.</source>
        <target>La Preuve d'Enjeu  (PoS = Proof of Stake) est un mécanisme de consensus nouveau et plus efficace proposé comme une alternative à la consommation intensive d'énergie et de puissance de calcul dans les mécanismes de consensus de Preuve de Travail (PoW). La PoS peut être trouvée dans de nombreuses nouvelles architectures comme Cardano [19] et Algorand [3] et peut être dans la prochaine version d'Ethereum. Dans la PoS, le nœud qui propose le bloc suivant est sélectionné par une combinaison d'enjeux (richesse), de tirage aléatoire et/ou d'âge. Cela atténue le problème de l'énergie du PoW mais pose également deux problématique importantes sur la table : l'attaque &quot;Rien à perdre&quot; et un risque de centralisation plus élevé.</target>
      </trans-unit>
      <trans-unit id="115" resname="4caa58bd5b72e9edfff6757a1107784e">
        <source>Proof  of  Meme  as  envisioned  in  Constellation  [20],  is  an algorithm  based  on  the  node’s  historical  participation  on  the network. Its behaviour is stored in a matrix of weights in the blockchain  and  supports  changes  over  time.  Also,  it  allows new  nodes  to  gain  trust  by  building  up  reputation.  The  main drawback  regarding  Sybil  attacks  is  alleviated  through  the NetFlow algorithm.</source>
        <target>Proof of Meme, tel qu'il est envisagé dans Constellation [20], est un algorithme basé sur la participation historique du nœud au réseau. Son comportement est stocké dans une matrice de pondération dans la blockchain et prend en charge les changements au fil du temps. Il permet également aux nouveaux nœuds de gagner la confiance des utilisateurs en se forgeant une réputation. Le principal inconvénient des attaques Sybil est atténué par l'algorithme NetFlow.</target>
      </trans-unit>
      <trans-unit id="116" resname="189a27ef5ad1c377b742daf17323fb32">
        <source>Delegated  Proof  of  Stake  (DPoS)  found  in  Bitshares  [21], Steemit  [22]  and  EOS  [23]  is  a  hybrid  between  Proof  of Authority and Proof of Stake in which the few nodes respon- sible  for  deploying  new  blocks  are  elected  by  stakeholders. Although it has a high throughput, the model is susceptible to human related social problems such as bribing and corruption. Also, a small number of delegates makes the system prone to DDoS attacks and centralization.</source>
        <target>La preuve d'autorité déléguée (Delegated Proof of Stake - DPoS), que l'on trouve dans Bitshares [21], Steemit [22] et EOS [23], est un hybride entre la preuve d'autorité et la preuve d'enjeu, dans lequel les quelques nœuds responsables du déploiement de nouveaux blocs sont élus par les parties prenantes. Bien que présentant un débit élevé, le modèle est sensible aux problèmes sociaux spécifiques à l'homme tels que la corruption. De plus, un petit nombre de délégués rend le système vulnérable aux attaques DDoS et à la centralisation.</target>
      </trans-unit>
      <trans-unit id="117" resname="48a393f7a002a4deca9683488b0b9276">
        <source>2  Secure Proof of Stake (SPoS)</source>
        <target>2 Preuve d'enjeu sécurisée (SPoS = Secure Proof of Stake)</target>
      </trans-unit>
      <trans-unit id="118" resname="4a4d3413fa9d47ed173193c75d898667">
        <source>Elrond’s  approach  to  consensus  is  made  by  combining random  validators’  selection,  eligibility  through  stake  and rating,  with  an  optimal  dimension  for  the  consensus  group. The algorithm is described in the steps below:</source>
        <target>L'approche d'Elrond en matière de consensus consiste à combiner la sélection aléatoire des validateurs, l'éligibilité à travers l'enjeu et de la notation, avec une dimension optimale pour le groupe de consensus. L'algorithme est décrit dans les étapes ci-dessous :</target>
      </trans-unit>
      <trans-unit id="119" resname="4c7b6ac43f8ef9108a2e2c61c6abf3c6">
        <source>1)  Each node ni  is defined as a tuple of public key (P k), rating  (default  is  0)  and  the  locked  stake.  If  ni   wishes to  participate  in  the  consensus,  it  has  to  first  register through  a  smart  contract,  by  sending  a  transaction  that contains an amount equal to the minimum required stake and other information (P ks, a public key derived from P k and nodeid that will be used for the signing process in order not to use a real wallet address).</source>
        <target>1) Chaque nœud ni est défini comme un tuple de clé publique (P k), de notation (par défaut 0) et l'enjeu verrouillé. Si ni souhaite participer au consensus, il doit d'abord s'enregistrer par le biais d'un contrat intelligent, en envoyant une transaction qui contient un montant égal à l'enjeu minimal requis et d'autres informations (P ks, une clé publique dérivée de P k et un nodeid qui sera utilisé pour le processus de signature afin de ne pas utiliser une adresse réelle de portefeuille).</target>
      </trans-unit>
      <trans-unit id="120" resname="c0c353aed64d7c7a66849da1b75013ad">
        <source>2)  The  node  ni   joins  the  node  pool  and  waits  for  the shard assignment at the end of the current epoch e. The shard assignment mechanism creates a new set of nodes containing  all  the  nodes  that  joined  in  epoch  e  and  all 33the  nodes  that  need  to  be  reshuffled  (less  than    1   of every  shard).  All  nodes  in  this  set  will  be  reassigned to  the  waiting  lists  of  shards.  Wj   represents  j’s  shard waiting list and Nsh  represents the number of shards. A node also has a secret key sk that by nature is not to be made public.</source>
        <target>2) Le nœud ni rejoint le pool de nœuds et attend l'affectation des shards à la fin de l'époque e en cours. Le mécanisme d'affectation des shards crée un nouvel ensemble de nœuds contenant tous les nœuds qui se sont joints à l'époque e et tous les 33 nœuds qui doivent être remélangés (moins de 1 de chaque shards). Tous les nœuds de cet ensemble seront réaffectés aux listes d'attente de shards. Wj représente la liste d'attente de shards de j et Nsh représente le nombre de shards. Un nœud possède également une clé secrète sk qui, par nature, ne doit pas être rendue publique.</target>
      </trans-unit>
      <trans-unit id="121" resname="79074dd047909d6362251160d86c8793">
        <source>ni  = (P ki, ratingi, stakei)</source>
        <target>ni = (P ki, ratingi, stakei)</target>
      </trans-unit>
      <trans-unit id="122" resname="4661a56f2879e9592f91d7b384cfffa9">
        <source>ni  ∈ Wj , 0 ≤ j &lt; Nsh</source>
        <target>ni Wj, 0 ≤ j &lt; Nsh</target>
      </trans-unit>
      <trans-unit id="123" resname="dcb8caba4883dc67cec0726874e55add">
        <source>3)  At the end of the epoch in which it has joined, the node will  be  moved  to  the  list  of  eligible  nodes  (Ej )  of  a shard j, where e is the current epoch.</source>
        <target>3) À la fin de l'époque il s'est joint, le nœud sera déplacé vers la liste des nœuds éligibles (Ej) d'un shard j, où e est l'époque courante.</target>
      </trans-unit>
      <trans-unit id="124" resname="aaa2814fd8557be8cf8b6832a3b66068">
        <source>ni  ∈ Wj,e−1  → ni  6∈ Wj,e, ni  ∈ Ej,e</source>
        <target>ni Wj, e−1 → ni 6Wj, e, ni Ej, e</target>
      </trans-unit>
      <trans-unit id="125" resname="7de52ae5c56aa3a30d924ef383b5837d">
        <source>4)  Each node from the list Ej  can be selected as part of an optimally dimensioned consensus group (in terms of security and communication), by a deterministic function, based  on  the  randomness  source  added  to  the  previous block,  the  round  r  and  a  set  of  variation  parameters. The random number, known to all shard nodes through gossip, cannot be predicted before the block is actually signed  by  the  previous  consensus  group.  This  property makes  it  a  good  source  of  randomness  and  prevents highly adaptive malicious attacks. We define a selection function  to  return  the  set  of  chosen  nodes  (consensus group) Nchosen  with the first being the block proposer, that  takes  following  parameters:  E,  r  and  sigr−1  -  the previous block signature.</source>
        <target>4) Chaque nœud de la liste Ej peut être sélectionné dans le cadre d'un groupe de consensus dimensionné de manière optimale (en termes de sécurité et de communication), par une fonction déterministe, basée sur le caractère aléatoire de la source ajoutée au bloc précédent, le tour r et un ensemble de paramètres de variation. Le nombre aléatoire, connu de tous les nœuds du shard par le biais d'un protocole de bavardage, ne peut être prédit avant que le bloc ne soit effectivement signé par le groupe de consensus précédent. Cette propriété en fait une bonne source aléatoire et empêche les attaques malveillantes hautement adaptatives. Nous définissons une fonction de sélection pour renvoyer l'ensemble des nœuds choisis (groupe de consensus) Nchosen, le premier étant le proposant du bloc, qui prend les paramètres suivants : E, r et sigr-1 - la signature du bloc précédent.</target>
      </trans-unit>
      <trans-unit id="126" resname="69952d902b38da6a36e790d2d59e2497">
        <source>Nchosen  = f(E, r, sigr−1), where Nchosen  ⊂ E</source>
        <target>Nchoisi = f (E, r, sigr−1), où Nchoisi E</target>
      </trans-unit>
      <trans-unit id="127" resname="125e7d77669b2d39579f34203a42de27">
        <source>5)  The block will be created by the block proposer and the validators  will  co-sign  it  based  on  a  modified  practical Byzantine Fault Tolerance (pBFT).</source>
        <target>5) Le bloc sera créé par le proposant de bloc et les validateurs le cosigneront sur la base du protocole &quot;practical Byzantine Fault Tolerance&quot;  (PbFt).</target>
      </trans-unit>
      <trans-unit id="128" resname="d3464263f5b896cbacc603f34e9a6767">
        <source>6)  If,  for  any  reason,  the  block  proposer  did  not  create  a block  during  its  allocated  time  slot  (malicious,  offline, etc.), round r will be used together with the randomness source  from  the  last  block  to  select  a  new  consensus group.</source>
        <target>6) Si, pour une raison quelconque, le proposant de bloc n'a pas créé de bloc pendant le créneau horaire qui lui était attribué (malveillant, hors ligne, etc.), le tour r sera utilisé en conjugaison avec la source aléatoire du dernier bloc pour sélectionner un nouveau groupe de consensus.</target>
      </trans-unit>
      <trans-unit id="129" resname="08b15a4fd2379a346d731401daa98957">
        <source>If the current block proposer acts in a malicious way, the rest of the group members apply a negative feedback to change its rating, decreasing or even cancelling out the chances that this particular node will be selected again. The feedback function for the block proposer (ni) in round number r, with parameter ratingModifier ∈ Z  is computed as:</source>
        <target>Si le proposant du bloc courant agit de manière malveillante, les autres membres du groupe émettront un retour négatif pour dégrader son classement, diminuant ou même annulant les chances que ce nœud particulier soit à nouveau sélectionné. La fonction de rétroaction pour le proposant de bloc (ni) dans le tour numéro r, avec le paramètre ratingModifier ∈ Z est calculée comme suit :</target>
      </trans-unit>
      <trans-unit id="130" resname="7b631127edf6ed070fae6112a8a33290">
        <source>feedbackfunction = ff(ni, ratingModifier, r)</source>
        <target>feedbackfunction = ff (ni, notationModificateur, r)</target>
      </trans-unit>
      <trans-unit id="131" resname="07a506fd6873d1b76a8e25f3b54ed713">
        <source>33the  nodes  that  need  to  be  reshuffled  (less  than    1   of every  shard).  All  nodes  in  this  set  will  be  reassigned to  the  waiting  lists  of  shards.  Wj   represents  j’s  shard waiting list and Nsh  represents the number of shards. A node also has a secret key sk that by nature is not to be made public.</source>
        <target>&lt; problème &gt;</target>
      </trans-unit>
      <trans-unit id="132" resname="52eaae0fffeef5b5145f1faec5380843">
        <source>When  ratingModifier  &lt;  0,  slashing  occurs  so  the  node ni  loses its stake.</source>
        <target>Lorsque RatingModifier &lt; 0, une coupure se produit de sorte que le nœud ni perde sa mise.</target>
      </trans-unit>
      <trans-unit id="133" resname="103001afdf69194c3f92c2b5310f2fd1">
        <source>The  consensus  protocol  remains  safe  in  the  face  of  DDoS attacks  by  having  a  high  number  of  possible  validators  from the list E (hundreds of nodes) and no way to predict the order of the validators before they are selected.</source>
        <target>Le protocole de consensus reste sûr face aux attaques DDoS dans la mesure où il peut s'appuyer sur un nombre élevé de validateurs possibles existants dans la liste E (centaines de nœuds) et dans la mesure ou il n'y a aucun moyen de prédire l'ordre des validateurs avant qu'ils ne soient sélectionnés.</target>
      </trans-unit>
      <trans-unit id="134" resname="b579eaa814eb0f75be2ddb90e7dd6605">
        <source>To reduce the communication overhead that comes with an increased  number  of  shards,  a  consensus  will  be  run  on  a composite block. This composite block is formed by:</source>
        <target>Pour réduire le cout additionnel de communication qui accompagne un nombre accru de shards, un consensus sera exécuté sur un bloc composite. Ce bloc composite est formé par :</target>
      </trans-unit>
      <trans-unit id="135" resname="b753494bf79334d1f93d167efdbf947e">
        <source>•   Ledger  block:  the  block  to  be  added  into  the  shard’s ledger, having all intra shard transactions and cross shard transactions for which confirmation proof was received;</source>
        <target>• Le bloc registre : le bloc à ajouter dans le registre du shard, comportant toutes les transactions intra shard ainsi que toutes les transactions inter shards pour lesquelles une preuve de confirmation a été reçue;</target>
      </trans-unit>
      <trans-unit id="136" resname="45ae1b07cb3bcab4f12be379ce212750">
        <source>•   Multiple mini-blocks: each of them holding cross shard transactions for a different shard;</source>
        <target>• Mini-blocs multiples : chacun d'eux détenant des transactions inter shards pour un shard différent ;</target>
      </trans-unit>
      <trans-unit id="137" resname="df9c30494e7d984f911a89a9a2f3102e">
        <source>The  consensus  will  be  run  only  once,  on  the  composite block containing both intra- and cross-shard transactions. After consensus  is  reached,  the  block  header  of  each  shard  is  sent to the metachain for notarization.</source>
        <target>Le consensus ne sera exécuté qu'une seule fois, sur le bloc composite contenant  les transactions à la fois intra- et inter-shards. Une fois le consensus obtenu, l'en-tête de bloc de chaque shard est envoyé à la métachaîne pour notarisation</target>
      </trans-unit>
      <trans-unit id="138" resname="376e587aebc25bf83000cd0f63ff5c20">
        <source>VI  Cryptographic Layer</source>
        <target>VI La couche cryptographique</target>
      </trans-unit>
      <trans-unit id="139" resname="99d33436aefc5bc02e2d5d966ca09ceb">
        <source>1  Signature Analysis</source>
        <target>1 Analyse des signatures</target>
      </trans-unit>
      <trans-unit id="140" resname="b266d0d1f5c3a7dde7b754fe2c62aaac">
        <source>Digital   signatures   are   cryptographic   primitives   used   to achieve  information  security  by  providing  several  properties like message authentication, data integrity and non-repudiation [24].</source>
        <target>Les signatures numériques sont des cryptographiques primitif utilisées pour assurer la sécurité de l'information en offrant plusieurs propriétés comme l'authentification du message, l'intégrité des données et la non-répudiation [24].</target>
      </trans-unit>
      <trans-unit id="141" resname="6fb4c81df69c451b97a5adfa2a160325">
        <source>Most of the schemes used for existing blockchain platforms rely  on  the  discrete  logarithm  (DL)  problem:  one-way  expo- nentiation  function  y  →  αymod p.  It  is  scientifically  proven that calculating the discrete logarithm with base is hard [25]. Elliptic  curve  cryptography  (ECC)  uses  a  cyclic  group  of points  instead  of  a  cyclic  group  of  integers.  The  scheme reduces  the  computational  effort,  such  that  for  key  lengths of only 160 - 256 bits, ECC provides same security level that RSA,  Elgamal,  DSA  and  others  provide  for  key  lengths  of1024 - 3072 bits (see Table 1 [24]).</source>
        <target>La plupart des schémas utilisés pour les plates-formes blockchaine existantes reposent sur le problème du logarithme discret (DL) : fonction d’exponentialliter unidirectionnelle y → αymod p. Il est scientifiquement prouvé que le calcul du logarithme discret avec base est difficile [25]. La cryptographie à courbe elliptique (ECC) utilise un groupe cyclique de points au lieu d'un groupe cyclique d'entiers. Ce système réduit l'effort de calcul, de sorte que pour des longueurs de clé de seulement 160 à 256 bits, l'ECC offre le même niveau de sécurité que RSA, Elgamal, DSA et d'autres fournissent pour des longueurs de clé de 1024 à 3072 bits (voir tableau 1 [24]).</target>
      </trans-unit>
      <trans-unit id="142" resname="7d6cefe0611b100aa51a649bf81c17c6">
        <source>The  reason  why  ECC  provides  a  similar  security  level  for much smaller parameter lengths is because existing attacks on elliptic curve groups are weaker than the existing integer DL attacks, the complexity of such algorithms require on average√p  steps  to  solve.  This  means  that  an  elliptic  curve  using  a prime  p  of  256  bit  length  provides  on  average  a  security  of</source>
        <target>La raison pour laquelle l'ECC offre un niveau de sécurité similaire pour des longueurs de paramètres beaucoup plus petites est que les attaques existantes sur des groupes de courbes elliptiques sont plus faibles que les attaques DL entières existantes, la complexité de ces algorithmes nécessitant une moyenne √p des étapes de résolution. Cela signifie qu'une courbe elliptique utilisant un p premier de 256 bits offre en moyenne un niveau de sécurité de</target>
      </trans-unit>
      <trans-unit id="143" resname="776f02c9313f9de9f33438b4bc0f61e1">
        <source>2128  steps needed to break it [24].</source>
        <target>2128 étapes nécessaires pour le briser [24].</target>
      </trans-unit>
      <trans-unit id="144" resname="8dff265ef957fee77a27a6b92635cdf2">
        <source>Both  Ethereum  and  Bitcoin  use  curve  cryptography,  with the ECDSA signing algorithm. The security of the algorithm is  very  dependent  on  the  random  number  generator,  because if the generator does not produce a different number on each query, the private key can be leaked [26].</source>
        <target>Ethereum et Bitcoin utilisent tous deux la cryptographie par courbe, avec l'algorithme de signature ECDSA. La sécurité de l'algorithme est très dépendante du générateur de nombres aléatoires, car si le générateur ne produit pas un nombre différent à chaque requête, la clé privée peut être perdue [26].</target>
      </trans-unit>
      <trans-unit id="145" resname="e2268ed636702454070ea610bb52673c">
        <source>Another  digital  signature  scheme  is  EdDSA,  a  Schnorr variant  based  on  twisted  Edwards  curves  that  support  fast arithmetic  [27].  In  contrast  to  ECDSA,  it  is  provably  non- malleable,  meaning  that  starting  from  a  simple  signature,  it is  impossible  to  find  another  set  of  parameters  that  defines the  same  point  on  the  elliptic  curve  [28],  [29].  Additionally, EdDSA  doesn’t  need  a  random  number  generator because it uses  a  nonce,  calculated  as  the  hash  of  the  private  key  and the message, so the attack vector of a broken random number generator that can reveal the private key is avoided. </source>
        <target>Un autre système de signature numérique est l'EdDSA, une variante de Schnorr basée sur des courbes Edwards qui permettent un calcul rapide [27]. Contrairement à l'ECDSA, il est prouvé qu'il est non malléable, ce qui signifie qu'à partir d'une simple signature, il est impossible de trouver un autre ensemble de paramètres qui définisse le même point sur la courbe elliptique [28], [29]. En outre, l'EdDSA n'a pas besoin d'un générateur de nombres aléatoires car il utilise un nonce, calculé comme le hachage de la clé privée et du message, ce qui permet d'éviter le vecteur d'attaque d'un générateur de nombres aléatoires brisé qui peut révéler la clé privée.</target>
      </trans-unit>
      <trans-unit id="146" resname="a4800cdf7c0c9a2d9d2d52c72dc46ef7">
        <source>TABLE 1: Bit lengths of public-key algorithms for different security levels</source>
        <target>TABLEAU 1 : Longueur des bits des algorithmes à clé publique pour différents niveaux de sécurité</target>
      </trans-unit>
      <trans-unit id="147" resname="4d6c20a8a2cdf58e957ce2867bd4f492">
        <source>Schnorr  signature  variants  are  gaining  more  attention  [8], [30]  due  to  a  native  multi-signature  capability  and  being provably  secure  in  the  random  oracle  model  [31].  A  multi- signature scheme is a combination of a signing and verification algorithms, where multiple signers, each with their own private and public keys, can sign the same message, producing a single signature  [32],  [33].  This  signature  can  then  be  checked  by a  verifier  which  has  access  to  the  message  and  the  public keys of the signers. A sub-optimal method would be to have each  node  calculate  his  own  signature  and  then  concatenate all  results  in  a  single  string.  However,  such  an  approach  is unfeasible as the generated string size grows with the number of  signers.  A  practical  solution  would  be  to  aggregate  the output  into  a  single  fixed  size  signature,  independent  of  the number  of  participants.  There  have  been  multiple  proposals of  such  schemes,  most  of  them  are  susceptible  to  rogue-key (cancellation)  attacks.  One  solution  for  this  problem  would be  to  introduce  a  step  where  each  signer  needs  to  prove possession  of  the  private  key  associated  with  its  public  key [34].</source>
        <target>Les variantes de signature de Schnorr attirent de plus en plus l'attention [8], [30] en raison de leur capacité multi-signature native et de leur sécurité prouvée dans le modèle de l'oracle aléatoire [31]. Un système multi-signature est une combinaison d'un algorithme de signature et de vérification, où plusieurs signataires, chacun avec ses propres clés privées et publiques, peuvent signer le même message, produisant une seule signature [32], [33]. Cette signature peut ensuite être vérifiée par un vérificateur qui a accès au message et aux clés publiques des signataires. Une méthode sous-optimale consisterait à demander à chaque nœud de calculer sa propre signature et de concaténer ensuite tous les résultats en une seule chaîne. Cependant, une telle approche est irréalisable car la taille de la chaîne générée augmente avec le nombre de signataires. Une solution pratique consisterait à agréger les résultats en une seule signature de taille fixe, indépendamment du nombre de participants. De tels systèmes ont été proposés à plusieurs reprises, la plupart d'entre eux étant susceptibles de faire l'objet d'attaques de type &quot;rogue-key&quot; (annulation). Une solution à ce problème serait d'introduire une étape où chaque signataire doit prouver la possession de la clé privée associée à sa clé publique [34].</target>
      </trans-unit>
      <trans-unit id="148" resname="703fb7443018fdb1d44bc510f3ac45c8">
        <source>Bellare  and  Neven  [35]  (BN)  proposed  a  secure  multi- signature  scheme  without  a  proof  of  possession,  in  the  plain public  key  model,  under  the  discrete  logarithm  assumption [31]. The participants commit first to their share Ri  by prop- agating  its  hash  to  all  other  signers  so  they  cannot  calculate a  function  of  it.  Each  signer  computes  a  different  challenge for their partial signature. However, this scheme sacrifices the public  key  aggregation.  In  this  case,  the  verification  of  the aggregated signature, requires the public key from each signer. A  recent  paper  by  Gregory  Maxwell  et  al.  [29]  proposes another multi-signature scheme in the plain public key model [36],  under  the  ’one  more  discrete  logarithm’  assumption (OMDL). This approach improves the previous scheme [35] by reducing the communication rounds from 3 to 2, reintroducing the key aggregation with a higher complexity cost.</source>
        <target>Bellare et Neven [35] (BN) ont proposé un système sécurisé à signatures multiples sans preuve de possession, dans le modèle à clé publique simple, sous l'hypothèse du logarithme discret [31]. Les participants s'engagent d'abord sur leur part de Ri en proposant son hachage à tous les autres signataires afin qu'ils ne puissent pas en calculer une fonction. Chaque signataire calcule un défi différent pour sa signature partielle. Toutefois, ce système sacrifie l'agrégation de la clé publique. Dans ce cas, la vérification de la signature agrégée nécessite la clé publique de chaque signataire. Un article récent de Gregory Maxwell et al (29) propose un autre schéma multi-signature dans le modèle de clé publique simple (36), sous l'hypothèse d'un &quot;logarithme plus discret&quot; (OMDL). Cette approche améliore le schéma précédent [35] en réduisant les cycles de communication de 3 à 2, réintroduisant l'agrégation de clés avec un coût de complexité plus élevé.</target>
      </trans-unit>
      <trans-unit id="149" resname="fc0732df491642abbc622c1df53b174a">
        <source>BLS  [4]  is  another  interesting  signature  scheme,  from  the Weil  pairing,  which  bases  its  security  on  the  Computational Diffie-Hellman assumption on certain elliptic curves and gen- erates  short  signatures.  It  has  several  useful  properties  like batch verification, signature aggregation, public key aggrega- tion,  making  BLS  a  good  candidate  for  threshold  and  multi- signature schemes.</source>
        <target>BLS [4] est un autre schéma de signature intéressant, issu de l'appariement de Weil, qui fonde sa sécurité sur l'hypothèse de la différence de calcul de Hellman sur certaines courbes elliptiques et génère de courtes signatures. Il possède plusieurs propriétés utiles comme la vérification par lots, l'agrégation de signatures, l'agrégation de clés publiques, ce qui fait du BLS un bon candidat pour les systèmes à seuil et à signatures multiples.</target>
      </trans-unit>
      <trans-unit id="150" resname="aba0570edcd7c9a9f79388aab0591e75">
        <source>Dan  Boneh,  Manu  Drijvers  and  Gregory  Neven  recently proposed a BLS multi-signature scheme [5], using ideas from the  previous  work  of  [35],  [30]  to  provide  the  scheme  with defenses  against  rogue  key  attacks.  The  scheme  supports efficient  verification  with  only  two  pairings  needed  to  verify a multi-signature and without any proof of knowledge of the secret  key  (works  in  the  plain  public  key  model).  Another advantage  is  that  the  multi-signature  can  be  created  in  only two communication rounds.</source>
        <target>Dan Boneh, Manu Drijvers et Gregory Neven ont récemment proposé un système multi-signature du BLS [5], utilisant des idées issues des travaux précédents [35], [30] pour fournir au système des défenses contre les attaques de clés malhonnêtes. Le système permet une vérification efficace avec seulement deux paires nécessaires pour vérifier une signature multiple et sans aucune preuve de la connaissance de la clé secrète (fonctionne dans le modèle de clé publique). Un autre avantage est que la multi-signature peut être créée en seulement deux cycles de communication.</target>
      </trans-unit>
      <trans-unit id="151" resname="016c61b92c902d4c3c1fc4beb603c166">
        <source>For traceability and security reasons, a consensus based on a reduced set of validators requires the public key from each signer.  In  this  context,  our  analysis  concludes  that  the  most appropriate multi-signature scheme for block signing in Elrond is  BLS  multi-signature  [5],  which  is  faster  overall  than  the other options due to only two communication rounds.</source>
        <target>Pour des raisons de traçabilité et de sécurité, un consensus basé sur un ensemble réduit de validateurs exige la clé publique de chaque signataire. Dans ce contexte, notre analyse conclut que le schéma multi-signature le plus approprié pour la signature en bloc à Elrond est le BLS multi-signature [5], qui est globalement plus rapide que les autres options en raison de seulement deux cycles de communication.</target>
      </trans-unit>
      <trans-unit id="152" resname="ca472f1d3e8c6ca0760f3360cec00b6b">
        <source>2  Block signing in Elrond</source>
        <target>2 La signature de bloc dans Elrond</target>
      </trans-unit>
      <trans-unit id="153" resname="8a591c68c598fd2640f0da789684d5a1">
        <source>For  block  signing,  Elrond  uses  curve  cryptography  based on  the  BLS  multi-signature  scheme  over  the  bn256  bilinear group, which implements the Optimal Ate pairing over a 256- bit Barreto Naehrig curve. The bilinear pairing is defined as:</source>
        <target>Pour la signature de blocs, Elrond utilise une cryptographie de courbe basée sur le schéma multi-signature BLS sur le groupe bilinéaire bn256, qui met en œuvre l'appariement Optimal Ate sur une courbe Barreto Naehrig 256 bits. L’appariement bilinéaire est défini comme suit:</target>
      </trans-unit>
      <trans-unit id="154" resname="fc6efeb2cf14641780ab0aa0813121e2">
        <source>e : g0  × g1  → gt                                              (1)</source>
        <target>e : g0 × g1 → gt (1)</target>
      </trans-unit>
      <trans-unit id="155" resname="2a5c6bcdb2e1f9fefb77b466935e6bbc">
        <source>where g0, g1  and gt  are elliptic curves of prime order p defined by bn256, and e is a bilinear map (i.e. pairing function). Let G0   and  G1   be  generators  for  g0   and  g1.  Also,  let  H0   be  a hashing function that produces points on the curve g0:</source>
        <target>où g0, g1 et gt sont des courbes elliptiques d'ordre premier p définies par bn256, et e est une carte bilinéaire (c'est-à-dire une fonction d'appariement). Soit G0 et G1 sont les générateurs de g0 et g1. Soit également H0 une fonction de hachage qui produit des points sur la courbe g0 :</target>
      </trans-unit>
      <trans-unit id="156" resname="16e273c32cee7c4e64f966d43b76590f">
        <source>H0  : M → g0                                                 (2)</source>
        <target>H0  : M → g0                                                 (2)</target>
      </trans-unit>
      <trans-unit id="157" resname="d45bba0e0d7d0dc2972232a0c296a0b0">
        <source>where  M  is  the  set  of  all  possible  binary  messages  of  any length. The signing scheme used by Elrond employs a second hasing function as well, with parameters known by all signers:</source>
        <target>où M est l'ensemble de tous les messages binaires possibles, quelle que soit leur longueur. Le système de signature utilisé par Elrond utilise également une seconde fonction de hasing, dont les paramètres sont connus de tous les signataires :</target>
      </trans-unit>
      <trans-unit id="158" resname="ddfaaa72e868bb44728182d6112ebb40">
        <source>H1  : M → Zp                                                (3) Each  signer  i  has  its  own  private/public  key  pair  (ski, P ki),</source>
        <target>H1 : M → Zp (3) Chaque signataire i a sa propre paire de clés privées/publiques (SKI, PKI),</target>
      </trans-unit>
      <trans-unit id="159" resname="d5251aaa1e1021d7fe873207940d0377">
        <source>where ski  is randomly chosen from Zp. For each key pair, the property P ki  = ski  · G1  holds.</source>
        <target>où ski est choisi au hasard dans Zp. Pour chaque paire de clés, la propriété P ki = ski - G1 est retenue.</target>
      </trans-unit>
      <trans-unit id="160" resname="661efff29bee0aab963a1c0e31e32475">
        <source>Let  L  =  P k1, P k2, ..., P kn   be  the  set  of  public  keys  of all  possible  signers  during  a  specific  round  which,  in  the case  of  Elrond,  is  the  set  of  public  keys  of  all  the  nodes  in the  consensus  group.  Below,  the  two  stages  of  block  signing process is presented: signing and verification.</source>
        <target>Soit L = P k1, P k2, ..., P kn est l'ensemble des clés publiques de tous les signataires possibles au cours d'un tour spécifique qui, dans le cas d'Elrond, est l'ensemble des clés publiques de tous les nœuds du groupe de consensus. Les deux étapes du processus de signature en bloc sont présentées ci-dessous : la signature et la vérification.</target>
      </trans-unit>
      <trans-unit id="161" resname="8433dd3e5a2690bdd95db21a6e6b71c5">
        <source>Practical signing - Round 1</source>
        <target>Signature pratique - Cycle 1</target>
      </trans-unit>
      <trans-unit id="162" resname="1a7d343edfa47a6d55b5c37088bdb2fa">
        <source>The  leader  of  the  consensus  group  creates  a  block  with transactions,   then   signs   and   broadcasts   this   block   to   the consensus group members.</source>
        <target>Le chef du groupe de consensus crée un bloc avec les transactions, puis signe et diffuse ce bloc aux membres du groupe de consensus.</target>
      </trans-unit>
      <trans-unit id="163" resname="c4b97441a25eff0f60287ab0645bf77f">
        <source>Practical signing - Round 2</source>
        <target>Signature pratique - Cycle 2</target>
      </trans-unit>
      <trans-unit id="164" resname="ecd950e0c97c9881ea9e1fa5f43d5645">
        <source>Each member of the consensus group (including the leader) who receives the block must validate it, and if found valid, it signs it with BLS and then sends the signature to the leader:</source>
        <target>Chaque membre du groupe de consensus (y compris le chef) qui reçoit le bloc doit le valider, et s'il le trouve valide, il le signe avec le BLS et envoie ensuite la signature au chef :</target>
      </trans-unit>
      <trans-unit id="165" resname="424a509b90f7b34ccc1cb1f81332c679">
        <source>Sigi  = ski  ∗ H0(m)                             (4)</source>
        <target>Sigi = ski ∗ H0(m) (4)</target>
      </trans-unit>
      <trans-unit id="166" resname="ae71a586756cdfe324473883f7f34751">
        <source>where Sigi  is a point on g0.</source>
        <target>Où Sigi est un point sur g0</target>
      </trans-unit>
      <trans-unit id="167" resname="c209b6750c496683fc230e38a8f4a538">
        <source>Practical signing - Round 3</source>
        <target>Signature pratique - Cycle 3</target>
      </trans-unit>
      <trans-unit id="168" resname="1ed5813f1af20fd8e996c99797854164">
        <source>3333The  leader  waits  to  receive  the  signatures  for  a  specific timeframe. If it does not receive at least  2  · n + 1 signatures in that timeframe, the consensus round is aborted. But if the leader does receive  2  · n + 1 or more valid signatures, it uses them to generate the aggregated signature:</source>
        <target>Le chef du groupe attend de recevoir les signatures pendant une période déterminée. S'il n'en reçoit pas au moins 2 - n + 1 signatures dans ce délai, le cycle de consensus est avorté. Mais si le leader reçoit 2 - n + 1 ou plus de signatures valables, il les utilise pour générer la signature agrégée :</target>
      </trans-unit>
      <trans-unit id="169" resname="71db86a392b56af3f3860125f5099a26">
        <source>where SigAgg  is a point on g0.</source>
        <target>Où SigAgg est un point sur g0</target>
      </trans-unit>
      <trans-unit id="170" resname="7483192f486658b019c01428db8afbd1">
        <source>The leader then adds the aggregated signature to the block together  with  the   selected  signers  bitmap   B,  where   a  1 indicates  that  the  corresponding  signer  in  the  list  L  had  its signature added to the aggregated signature SigAgg.</source>
        <target>Le leader ajoute ensuite la signature agrégée au bloc avec les signataires sélectionnés en bitmap B, où un 1 indique que le signataire correspondant dans la liste L a vu sa signature ajoutée à la signature agrégée SigAgg.</target>
      </trans-unit>
      <trans-unit id="171" resname="fd3c73d439fafe2f7ed5015f0dd10b1f">
        <source>Practical verification</source>
        <target>Vérification pratique</target>
      </trans-unit>
      <trans-unit id="172" resname="4b94b1865ee5dbb0512da8585cf23644">
        <source>Given the list of public keys L, the bitmap for the signers B, the  aggregated  signature  SigAgg,  and  a  message  m  (block), the verifier computes the aggregated public key:</source>
        <target>Compte tenu de la liste des clés publiques L, de la bitmap des signataires B, de la signature agrégée SigAgg et d'un message m (bloc), le vérificateur calcule la clé publique agrégée :</target>
      </trans-unit>
      <trans-unit id="173" resname="c52899640c05751dfdeb1122dd101691">
        <source>P kAgg = X H1(P ki) · P ki  · Bi                          (6)</source>
        <target>P kAgg = X H1(P ki) · P ki · Bi (6)</target>
      </trans-unit>
      <trans-unit id="174" resname="0757f5c00ea12eb7aad7c638bef63626">
        <source>i</source>
        <target>i</target>
      </trans-unit>
      <trans-unit id="175" resname="d6687fbffc8a6ff718df7540cb8cf708">
        <source>The result, P kAgg, is a point on g1. The final verification is where e is the pairing function.</source>
        <target>Le résultat, P kAgg, est un point sur g1. La vérification finale est l'endroit où e est la fonction d'appariement.</target>
      </trans-unit>
      <trans-unit id="176" resname="44778aa17d2f910093099e54d87a1144">
        <source>e(G1, SigAgg) == e(P kAgg, H0(m))              (7)</source>
        <target>e(G1, SigAgg) == e(P kAgg, H0(m)) (7)</target>
      </trans-unit>
      <trans-unit id="177" resname="fd1a64d352118ceca0ced69c5f795e88">
        <source>VII  Cross-shard Execution</source>
        <target>VII Exécution inter shards</target>
      </trans-unit>
      <trans-unit id="178" resname="d0b5917b6f0dc82faa4f391127b2d3e1">
        <source>For an in depth example of how the cross-shard transactions are  being  executed  and  how  the  communication  between shards and the metachain occurs, we are simplifying the entire process to just two shards and the metachain. Assuming that a  user  generates  a  transaction  from  his  wallet,  which  has  an address in shard 0 and wants to send ERDs to another user that has a wallet with an address in shard 1, the steps depicted in Fig. 4 are required for processing the cross-shard transaction. As mentioned in chapter V - Consensus via Secure Proof of Stake,  the  blocks  structure  is  represented  by  a  block  Header that contains information about the block (block nonce, round, proposer,  validators  timestamp  etc),  and  a  list  of  miniblocks for each shard that contain the actual transactions inside. Every miniblock contains all transactions that have either the sender in  the  current  shard  and  the  receiver  in  another  shard  or  the sender  in  a  different  shard  and  the  destination  in  the  current shard. In our case, for a block in shard 0, there will normally be 3 miniblocks:</source>
        <target>Pour un exemple approfondi de la manière dont les opérations inter shards sont exécutées et illustrer comment la communication entre les shards et la métachaîne se déroulent, nous simplifierons l'ensemble du processus pour ne mettre en jeu que deux shards adossés à la métachaîne. En supposant qu'un utilisateur génère une transaction à partir de son portefeuille, qui a une adresse dans le shard 0 et souhaite envoyer des ERD à un autre utilisateur qui a un portefeuille avec une adresse dans le shard 1, les étapes décrites dans la figure 4 sont nécessaires pour traiter la transaction inter shards. Comme mentionné dans le chapitre V - Consensus via preuve d'enjeu sécurisée, la structure des blocs est représentée par un en-tête de bloc qui rassemble des informations sur le bloc (nombre ad hoc du bloc = &quot;nonce&quot; du bloc, tour, proposant, horodatage des validateurs, etc.), et une liste de miniblocs de chaque shard à l'intérieur duquel sont contenues les transactions en question. Chaque minibloc contient toutes les transactions qui ont soit l'émetteur dans le shard actuel et le récepteur dans un autre shard, soit l'émetteur dans un shard différent et la destination dans le shard actuel. Dans notre cas, pour un bloc dans le shard 0, il y aura normalement 3 miniblocs :</target>
      </trans-unit>
      <trans-unit id="179" resname="b1c61e8b5fef02d882fb259a241a0826">
        <source>•   miniblock  0:  containing  the  intrashard  transactions  for shard 0</source>
        <target>• miniblock 0 : contenant les transactions intra shard pour le shard 0</target>
      </trans-unit>
      <trans-unit id="180" resname="b29978321c4517be016d3534ee4aeab2">
        <source>•   miniblock 1: containing cross-shard transactions with the sender in shard 0 and destination in shard 1</source>
        <target>• miniblock 1 : contenant les transactions inter shards avec l'expéditeur dans le shard 0 et la destination dans le shard 1</target>
      </trans-unit>
      <trans-unit id="181" resname="7b77c5715ea8ba672014bb770482d4bc">
        <source>•   miniblock  2:  containing  cross-shard  transactions  with sender  in  shard  1  and  destination  in  shard  0.  These transactions  were  already  processed  in  the  sender  shard 1  and  will  be  finalized  after  the  processing  also  in  the current shard.</source>
        <target>• miniblock 2 : contenant les transactions inter shards avec l'expéditeur dans le shard 1 et la destination dans le shard 0. Ces transactions ont déjà été traitées dans le shard de l'expéditeur 1 et seront également finalisées après le traitement dans le shard courant.</target>
      </trans-unit>
      <trans-unit id="182" resname="287e1559d0895d9ea86a31d2f6412417">
        <source>There  is  no  limitation  on  the  number  of  miniblocks  with the same sender and receiver in one block. Meaning multiple miniblocks  with  the  same  sender  and  receiver  can  appear  in the same block.</source>
        <target>Il n'y a pas de limite sur le nombre de miniblocs avec le même expéditeur et le même récepteur dans un bloc. Ce qui signifie que plusieurs miniblocs avec le même expéditeur et le même récepteur peuvent apparaître dans le même bloc.</target>
      </trans-unit>
      <trans-unit id="183" resname="0d94e04f71b914976f206be3d13110f6">
        <source>1  Processing</source>
        <target>1 Traitement</target>
      </trans-unit>
      <trans-unit id="184" resname="fe04831b8f30fe5b3309af9620942bcc">
        <source>Currently   the   atomic   unit   of   processing   in   cross-shard execution  is  a  miniblock:  either  all  the  transactions  of  the miniblock are processed at once or none and the miniblock’s execution will be retried in the next round.</source>
        <target>Actuellement, l'unité atomique de traitement inter shard est le minibloc : soit toutes les transactions du minibloc sont traitées en même temps, soit aucune, et l'exécution du minibloc sera retentée au tour suivant.</target>
      </trans-unit>
      <trans-unit id="185" resname="07b65359f6330471dd521bdb187bd82f">
        <source>Our cross-shard transaction strategy uses and asynchronous model. Validation and processing is done first in sender’s shard and then in receivers’ shard. Transactions are first dispatched in  the  sender’s  shard,  as  it  can  fully  validate  any  transaction initiated  from  the  account  in  this  shard  –  mainly  the  current balance.  Afterwards,  in  the  receivers’  shard,  the  nodes  only need  proof  of  execution  offered  by  metachain,  do  signature verification  and  check  for  replay  attack  and  finally  update the  balance  for  the  receiver,  adding  the  amount  from  the transaction.</source>
        <target>Notre stratégie de transactions inter shards utilise un modèle asynchrone. La validation et le traitement sont effectués d'abord dans le shard de l'expéditeur, puis dans le shard du destinataire. Les transactions sont d'abord expédiées dans le shard de l'expéditeur, car il peut valider entièrement toute transaction initiée à partir du compte dans ce shard - principalement le solde courant. Ensuite, dans le tesson du récepteur, les nœuds n'ont besoin que de la preuve d'exécution offerte par la métachaîne, font la vérification de la signature et vérifient l'absence d'attaque par rediffusion et enfin mettent à jour le solde pour le récepteur, en ajoutant le montant de la transaction.</target>
      </trans-unit>
      <trans-unit id="186" resname="eebef216bb01c2e3ddff1d760ee94a8b">
        <source>Shard 0 processes both intra-shard transactions in miniblock 0 and a set of cross-shard transactions that have addresses from shard  1  as  a  receiver  in  miniblock  1.  The  block  header  and miniblocks are sent to the metachain. The metachain notarizes the  block  from  shard  0,  by  creating  a  new  metachain  block (metablock) that contains the following information about each miniblock: sender shard ID, receiver shard ID, miniblock hash.</source>
        <target>Le shard 0 traite à la fois les transactions intra shard dans le minibloc 0 et un ensemble de transactions inter shard qui ont des adresses du shard 1 comme récepteur dans le minibloc 1. L'en-tête du bloc et les miniblocs sont envoyés à la métachaîne. La métachaîne notifie le bloc du shard 0, en créant un nouveau bloc de métachaîne (metablock) qui contient les informations suivantes sur chaque minibloc : ID du shard émetteur, ID du shard récepteur, hachage du minibloc.</target>
      </trans-unit>
      <trans-unit id="187" resname="c05f747d34385e96ff7ec215449c388d">
        <source>Fig. 4: Cross-shard transaction processing</source>
        <target>Figure 4 : Traitement des transactions inter shards</target>
      </trans-unit>
      <trans-unit id="188" resname="6695923a6043b26a98b7d6227a0033ba">
        <source>Shard  1  fetches  the  hash  of  miniblock  1  from  metablock, requests  the  miniblock  from  shard  0,  parses  the  transaction list, requests missing transactions (if any), executes the same miniblock  1  in  shard  1  and  sends  to  the  metachain  resulting block.  After  notarization  the  cross  transaction  set  can  be considered finalized.</source>
        <target>Le shard 1 récupère le hachage du minibloc 1 dans le métabloc, demande le minibloc du shard 0, analyse la liste des transactions, requête les transactions manquantes (le cas échéant), exécute le même minibloc 1 dans le shard 1 et envoie au bloc résultant de la métachaîne. Après la notarisation, l'ensemble des transactions inter shards peut être considéré comme finalisée.</target>
      </trans-unit>
      <trans-unit id="189" resname="678e961e077679332f71badcff2080ab">
        <source>The next diagram shows the number of rounds required for a transaction to be finalized. The rounds are considered between the  first  inclusion  in  a  miniblock  until  the  last  miniblock  is notarised.</source>
        <target>Le diagramme suivant montre le nombre de tours nécessaires pour qu'une transaction soit finalisée. Les tours sont comptabilisés entre la première inclusion dans un minibloc et la notarisation du dernier minibloc.</target>
      </trans-unit>
      <trans-unit id="190" resname="ed26c6ee08ac21bef0fe47927e8fb2f7">
        <source>VIII  Smart Contracts</source>
        <target>VIII Smart contracts</target>
      </trans-unit>
      <trans-unit id="191" resname="4b818235d61432bbf70f0dd627b617a8">
        <source>The  execution  of  smart  contracts  is  a  key  element  in  all future blockchain architectures. Most of the existing solutions avoid to properly explain the transactions and data dependency. This context leads to the following two scenarios:</source>
        <target>L'exécution de smart contracts est un élément clé pour toutes les futures architectures de chaînes de blocs. La plupart des solutions existantes évitent de clarifier correctement les dépendances entre les transactions et les données. Ce contexte conduit aux deux scénarios suivants :</target>
      </trans-unit>
      <trans-unit id="192" resname="7c5bb68c9b9048723694e52bbae0430f">
        <source>1)  When there is no direct correlation between smart con- tract transactions, as displayed in Fig. 5, any architecture can  use  out  of  order  scheduling.  This  means  there  are no  additional  constraints  on  the  time  and  place  (shard) where a smart contract is executed.</source>
        <target>1) Lorsqu'il n'y a pas de corrélation directe entre les transactions des smart contracts, comme le montre la figure 5, toute architecture peut utiliser un ordonnancement qui ne garantit pas l'ordre. Cela signifie qu'il n'y a pas de contraintes supplémentaires ni sur le moment, ni sur le lieu (shard) où un smart contract est exécuté.</target>
      </trans-unit>
      <trans-unit id="193" resname="7ec64f4b0f79c010cb696a1c431d90b4">
        <source>2)  The second scenario refers to the parallelism induced by the  transactions  that  involve  correlated  smart  contracts [37].  This  case,  reflected  in  Fig.  6,  adds  additional pressure on the performance and considerably increases the  complexity.  Basically  there  must  be  a  mechanism to  ensure  that  contracts  are  executed  in  the  right  order and  on  the  right  place  (shard).  To  cover  this  aspect, Elrond  protocol  proposes  a  solution  that  assigns  and moves the smart contract to the same shard where their static dependencies reside. This way most, if not all SC calls  will  have  dependencies  in  the  same  shard  and  no cross-shard locking/unlocking will be needed.</source>
        <target>2) Le second scénario fait référence au parallélisme induit par les transactions qui impliquent des smart contracts corrélés [37]. Ce cas, illustré à la figure 6, ajoute une pression supplémentaire sur les performances et augmente considérablement la complexité. Fondamentalement, il doit y avoir un mécanisme permettant de s'assurer que les contrats sont exécutés dans le bon ordre et au bon endroit (shard). Pour couvrir cet aspect, le protocole Elrond propose une solution qui assigne et déplace le smart contract vers le shard même qui maintient ses dépendances statiques. De cette façon, la plupart, voire la totalité des appels Smart Contracts auront des dépendances réduites au même shard  et aucun verrouillage/déverrouillage inter shards ne sera nécessaire.</target>
      </trans-unit>
      <trans-unit id="194" resname="6942da9ea5be8a6fc312141d87295dba">
        <source>Elrond focuses on the implementation of the Elrond Virtual Machine,  an  EVM  compliant  engine.  The  EVM  compliance</source>
        <target>Elrond se concentre sur la mise en œuvre de la machine virtuelle Elrond, un moteur conforme à la norme EVM. La conformité EVM</target>
      </trans-unit>
      <trans-unit id="195" resname="430ecace03de95a1141c1f9dc7d8d144">
        <source>Fig. 5: Independent transaction processing under simple smart contracts that can be executed out of order</source>
        <target>Fig. 5: Traitement indépendant des transactions dans le cadre de smart contracts simples qui peuvent être exécutés sans garantir l'ordre</target>
      </trans-unit>
      <trans-unit id="196" resname="a7c89182fdcc35ba00060a21c5a464cf">
        <source>Fig. 6: Mechanism for correlated smart contracts that can be executed only sequentially</source>
        <target>Figure 6 : Mécanisme pour les smart contracts corrélés qui  peuvent uniquement être exécutés séquentiellement</target>
      </trans-unit>
      <trans-unit id="197" resname="b03df34fee0ddd3b2e0677a275ccf89d">
        <source>Fig. 7: Abstraction Layer for Smart Contracts</source>
        <target>Fig. 7 : Couche d'abstraction pour les smart contracts</target>
      </trans-unit>
      <trans-unit id="198" resname="859a8b8937cab5f27ea61451e821a7d6">
        <source>is extremely important for adoption purposes, due to the large number of smart contracts built on Ethereum’s platform.</source>
        <target>est extrêmement importante à des fins d'adoption, en raison du grand nombre de smart contracts construits sur la plateforme d'Ethereum.</target>
      </trans-unit>
      <trans-unit id="199" resname="f81403b7e9b31e34a524ae067c27a2e2">
        <source>The Elrond Virtual Machine’s implementation will hide theunderlying architecture isolating the smart contract developers from  system  internals  ensuring  a  proper  abstraction  layer,  as displayed in Fig. 7.</source>
        <target>L'implémentation de la machine virtuelle Elrond masquera l'architecture sous-jacente isolant les développeurs de smart contracts des systèmes internes assurant ainsi une couche d'abstraction appropriée, comme illustré à la figure 7.</target>
      </trans-unit>
      <trans-unit id="200" resname="a629b9f66da56a84c0c7d58b35315267">
        <source>In Elrond, cross chain interoperability can be implemented by using an adapter mechanism at the Virtual Machine level as proposed by Cosmos [38]. This approach requires specialized adapters and an external medium for communication between adapter SC for each chain that will interoperate with Elrond. The  value  exchange  will  be  operated  using  some  specialized smart  contracts  acting  as  asset  custodians,  capable  of  taking custody  of  adapted  chain  native  tokens  and  issuing  Elrond native tokens.</source>
        <target>Dans Elrond, l'interopérabilité entre chaînes peut être mise en œuvre en utilisant un mécanisme d'adaptation au niveau de la machine virtuelle, comme le propose Cosmos [38]. Cette approche nécessite des adaptateurs spécialisés et un moyen de communication externe entre les adaptateurs Smart Contracts pour chaque chaîne qui interopérera avec Elrond. L'échange de valeur sera opéré à l'aide de certains smart contracts spécialisés agissant en tant que dépositaires, aptes à assurer la garde des jetons natifs de la chaîne ainsi adaptée et d'émettre des jetons natifs Elrond.</target>
      </trans-unit>
      <trans-unit id="201" resname="7de3399b6972b9aae9ff9ac424d268c1">
        <source>1  VM Infrastructure</source>
        <target>1 infrastructure de machines virtuelles</target>
      </trans-unit>
      <trans-unit id="202" resname="57ceb53483ac588c5bc14ae082440cb6">
        <source>Elrond builds its VM infrastructure on top of the K Frame- work,  which  is  an  executable  semantic  framework  where programming  languages,  calculi,  as  well  as  type  systems  or formal analysis tools can be defined [39].</source>
        <target>Elrond construit son infrastructure de Machines Virtuelles au dessus du Framework K, qui est un framework sémantique exécutable permettant de définir des langages de programmation, de calculs, ainsi que des systèmes de types ou des outils d'analyse formels [39].</target>
      </trans-unit>
      <trans-unit id="203" resname="d834cfbe5232eb8fbf600a63a4a4624e">
        <source>The  greatest  advantage  of  using  the  K  framework  is  that with  it,  smart  contract  languages  can  be  unambiguously  de- fined,  eliminating  the  potential  for  unspecified  behavior  and bugs that are hard to detect.</source>
        <target>Le plus grand avantage de l'utilisation du Framework K c'est qu'avec lui, les langages des smarts contract peuvent être définis de manière non- ambiguë, ce qui élimine le risque de comportements non spécifiés et de bogues difficiles à détecter.</target>
      </trans-unit>
      <trans-unit id="204" resname="8f62538a39f77da3a2286f1bc63a5099">
        <source>The K Framework is executable, in the sense that the semantic specifications of languages can be directly used as working interpreters  for  the  languages  in  question.  More  specifically, one  can  either  run  programs  against  the  specifications  using the  K  Framework  core  implementation  directly,  or  one  can generate  an  interpreter  in  several  programming  languages. These  are  also  referred  to  as  ”backends”.  For  the  sake  of execution  speed  and  ease  of  interoperability,  Elrond  uses  its own custom-built K Framework backend.</source>
        <target>Le Framework K est exécutable, en ce sens que les spécifications sémantiques des languages peuvent être utilisé directement comme des interpréteurs de langages opérationnels. Plus précisément, on peut soit exécuter des programmes en fonction des spécifications en utilisant directement l'implémentation coeur du Framework K, soit générer un interpréteur dans plusieurs langages de programmation différents. Ces derniers sont également appelés &quot;backends&quot;. Pour des raisons de rapidité d'exécution et de facilité d'interopérabilité, Elrond utilise son propre backend du Framework K, qui est construit sur mesure.</target>
      </trans-unit>
      <trans-unit id="205" resname="b3dbd9421cb93dfe53b55dda32d31edb">
        <source>2  Smart contract languages</source>
        <target>2 Languages des Smart Contracts</target>
      </trans-unit>
      <trans-unit id="206" resname="5d01ff65e75703a822a3337bbb3bd6b5">
        <source>One  great  advantage  of  the  K  Framework  is  that  one  can generate an interpreter for any language defined in K, without the  need  for  additional  programming.  This  also  means  that interpreters  produced  this  way  are  ”correct-by-construction”.</source>
        <target>Un grand avantage du framework K est que l'on peut générer un interpréteur pour n'importe quelle langue définie en K, sans avoir besoin de programmation supplémentaire. Cela signifie également que les interpréteurs produits de cette manière sont &quot;corrects par construction&quot;.</target>
      </trans-unit>
      <trans-unit id="207" resname="cc26ce6edaa3fe95296c0430c5cf43c8">
        <source>There are several smart contract languages specified in the K Framework already, or with their specifications under develop- ment. Elrond Network will support three low-level languages: IELE VM, KEVM, and WASM.</source>
        <target>Il existe déjà plusieurs langages de smart contracts spécifiés dans le Framework K, ou dont les spécifications sont en cours d'élaboration. Le réseau Elrond prendra en charge trois langages de bas niveau : IELE VM, KEVM et WASM.</target>
      </trans-unit>
      <trans-unit id="208" resname="1d9813dea657de6ffccbf16b7e4b76a9">
        <source>•   IELE VM is an intermediate-level language, in the style of  LLVM,  but  adapted  for  the  blockchain.  It  was  built directly in K, no other specification or implementation of it  exists  outside  of  the  K  framework  [40].  Its  purpose is  to  be  human  readable,  fast,  and  to  overcome  some limitations of EVM. Elrond uses a slightly altered version of  IELE  -  most  changes  are  related  to  account  address management.  Smart  contract  developers  can  program  in IELE  directly,  but  most  will  choose  to  code  in  Solidity and then use a Solidity to IELE compiler, as can be seen in Fig. 8.</source>
        <target>- IELE VM est un langage de niveau intermédiaire, dans le style de LLVM, mais adapté à la chaîne de blocs. Il a été construit directement en K, aucune autre spécification ou implémentation de celui-ci n'existe en dehors du framework K [40]. Son but est d'être lisible par l'homme, rapide, et de surmonter certaines limitations de l'EVM. Elrond utilise une version légèrement modifiée d'IELE - la plupart des changements sont liés à la gestion des adresses des comptes. Les développeurs de smart contracts peuvent programmer directement en IELE, mais la plupart choisiront de coder en Solidity et d'utiliser ensuite un compilateur Solidity to IELE, comme on peut le voir sur la figure 8.</target>
      </trans-unit>
      <trans-unit id="209" resname="b8dcf34caa5cb796d70fe9ab2c543a9d">
        <source>•   KEVM  is  a  version  of  the  Ethereum  Virtual  Machine (EVM), written in K [41]. Certain vulnerabilities of EVM are fixed in the K version, or the vulnerable features are left out entirely.</source>
        <target>- KEVM est une version de la machine virtuelle Ethereum (EVM), écrite en K [41]. Certaines vulnérabilités de l'EVM sont corrigées dans la version en K, et les fonctionnalités vulnérables sont entièrement écartées.</target>
      </trans-unit>
      <trans-unit id="210" resname="a05e2c57d305f8ecc845594ace29d904">
        <source>•   Web  Assembly  (WASM)  is  a  binary  instruction  format for a stack-based virtual machine, which can be used for running smart contracts. A WASM infrastructure enables developers to write smart contracts in C/C++, Rust, C#, and others.</source>
        <target>- Le Web Assembly (WASM) est un format d'instruction binaire, destiné aux machines virtuelles à mémoire de pile, qui peut être utilisé pour exécuter des smart contracts. Une infrastructure WASM permet aux développeurs d'écrire des smart contracts en C/C++, Rust, C#, et autres</target>
      </trans-unit>
      <trans-unit id="211" resname="8acd8d48c76822d7be95d96a4ca4e57b">
        <source>Having  a  language  specification  and  generating  the  inter- preter is only half of the challenge. The other half is integrating the  generated  interpreter  with  the  Elrond  network.  We  have built a common VM interface, that enables us to plug in any VM  into  an  Elrond  node  as  shown  in  Fig.  9.  Each  VM  then has an adapter that implements this interface. Each contract is saved as bytecode of the VM for which it was compiled and runs on its corresponding VM.</source>
        <target>Avoir une spécification linguistique et générer l'inter-préteur n'est que la moitié du défi. L'autre moitié consiste à intégrer l'interprète généré au réseau Elrond. Nous avons construit une interface VM commune, qui nous permet de connecter n'importe quelle VM à un nœud Elrond, comme le montre la figure 9. Chaque VM dispose alors d'un adaptateur qui met en œuvre cette interface. Chaque contrat est enregistré comme bytecode de la VM pour laquelle il a été compilé et fonctionne sur sa VM correspondante.</target>
      </trans-unit>
      <trans-unit id="212" resname="0b20ce9733abd8d68a364251667c59c0">
        <source>3  Support for formal modelling and verification</source>
        <target>3  Assistance à la modélisation et à la vérification formelles</target>
      </trans-unit>
      <trans-unit id="213" resname="665f36211d27a0a39bec0a6e6ebb6ede">
        <source>Because the smart contract languages are formally defined in K Framework, it is possible to perform formal verification of  smart  contracts  written  in  these  languages.  To  do  this,  it is necessary to also formally model their requirements, which can also be performed using the K Framework [42].</source>
        <target>Comme les langages des smart contracts sont formellement définis dans le cadre K, il est possible de procéder à une vérification formelle des smart contracts rédigés dans ces langages. Pour ce faire, il est nécessaire de modéliser formellement leurs exigences, ce qui peut également être fait en utilisant le Cadre K [42].</target>
      </trans-unit>
      <trans-unit id="214" resname="deeb1d94b62ce1fa7f27167a65b9bd3b">
        <source>Fig. 8: Elrond VM execution</source>
        <target>Fig. 8 : Exécution de la Machine Virtuelle Elrond</target>
      </trans-unit>
      <trans-unit id="215" resname="5768e2c8a5d1fbbf1b41e0dba96df01b">
        <source>Fig. 9: Elrond VM components</source>
        <target>Fig. 9 : Composants de la Machine Virtuelle Elrond</target>
      </trans-unit>
      <trans-unit id="216" resname="74f80ed36473e206647eae1e754c139a">
        <source>4  Smart contracts on the sharded architecture</source>
        <target>4 Smart Contracts sur une architecture de shards</target>
      </trans-unit>
      <trans-unit id="217" resname="73f4ad6bac3b22a349d8b859aa019671">
        <source>Smart  contracts  on  sharded  architectures  are  still  in  the early  stages  of  research  and  development  and  pose  serious challenges. Protocols like Atomix [7] or S-BAC [9] represent a starting point. Dynamic smart contract dependencies cannot be  resolved  by  moving  the  SCs  into  the  same  shard,  as  at deployment time, not all the dependencies can be calculated.</source>
        <target>Les Smart Contracts sur les architectures en Shards n'en sont encore qu'à leurs débuts et posent de sérieux problèmes. Des protocoles comme Atomix [7] ou S-BAC [9] représentent un point de départ. Les dépendances des Smart Contracts dynamiques ne peuvent pas être résolues en déplaçant les Smart Contracts dans le même Shard, car au moment du déploiement, toutes les dépendances ne peuvent pas être calculées.</target>
      </trans-unit>
      <trans-unit id="218" resname="80a8702b52b4feff3383b9cfc4c1de9f">
        <source>Solution currently research in the space:</source>
        <target>Solution en cours de recherche dans ce champ : </target>
      </trans-unit>
      <trans-unit id="219" resname="16c50882ea2d85051b83f9f2f1d49829">
        <source>1)  A locking mechanism that allows the atomic execution of smart contract from different shards, ensures that the involved  SCs  will  be  either  all  executed  at  the  same time,  or  none  at  all.  This  requires  multiple  interaction messages  and  synchronization  between  consensuses  of different shards. [9]</source>
        <target>1) Un mécanisme de verrouillage qui permet l'exécution atomique de Smart Contracts à partir de différents Shards, garantit que les Smart Contracts concernés seront, ou bien tous exécutés en même temps, ou alors aucun d'entre eux. Cela nécessite de multiples messages d'interaction et une synchronisation entre les consensus des différents Shards. [9]</target>
      </trans-unit>
      <trans-unit id="220" resname="4a56f095e6ff54c8ca97622d909d3665">
        <source>2)  Cross-shard contract yanking proposal for Ethereum 2.0 would move that smart contract code and data into the caller  shard  at  the  execution  time.  Atomic  execution  is not  needed,  but  the  locking  mechanism  is  mandatory on  the  moved  SC,  which  would  block  the  execution of  SC  for  other  transactions.  The  locking  mechanism is  simpler,  but  it  needs  to  transfer  the  whole  internal state of the SC. [43]</source>
        <target>2) La proposition de transfert de contrats inter Shards pour Ethereum 2.0 permettrait de transférer le code et les données de ce Smart Contract dans le Shard de l'appelant au moment de l'exécution. L'exécution atomique n'est pas nécessaire, mais le mécanisme de verrouillage est obligatoire sur le Smart Contract déplacé, ce qui bloquerait l'exécution du Smart Contract pour d'autres transactions. Le mécanisme de verrouillage est plus simple, mais il doit transférer l'ensemble de l'état interne du SC. [43]</target>
      </trans-unit>
      <trans-unit id="221" resname="710f6dd9d007c6324ec1e737c824bb11">
        <source>Following  Ethereum’s  model,  Elrond  has  the  following transaction types:</source>
        <target>Suivant le modèle d'Ethereum, Elrond présente les types de transaction suivants :</target>
      </trans-unit>
      <trans-unit id="222" resname="36fefb0a90da990e2a59861f2608546d">
        <source>1)  SC  construction  and  deployment:  transactions  receiver address  is  empty  and  data  field  contains  the  smart contract code as byte array;</source>
        <target>1) Construction et déploiement de Smart Contract: l'adresse du destinataire des transactions est vide et le champ de données contient le code du Smart Contract sous forme de tableau d'octets ;</target>
      </trans-unit>
      <trans-unit id="223" resname="51793dc8b371541a73b9c2c5993e4c34">
        <source>2)  SC  method  invoking:  transaction  has  a  non  empty  re- ceiver address and that address has an associated code;</source>
        <target>2) Méthode d'invocation du Smart Contract : la transaction contient une adresse de destinataire non vide et cette adresse dispose d'un code associé ;</target>
      </trans-unit>
      <trans-unit id="224" resname="592b7a8c366345409dff5ee22076b634">
        <source>3)  Payment  transactions:  transaction  has  a  non  empty  re- ceiver and that address does not have code.</source>
        <target>3) Transactions de paiement : la transaction contient un destinataire non vide et cette adresse ne dispose pas de code associé.</target>
      </trans-unit>
      <trans-unit id="225" resname="14a863e60121af408435bf52ccfb3ef9">
        <source>Elrond’s  approach  to  this  problem  is  to  use  asynchronous cross-shard  execution  model  in  case  of  smart  contracts.  The user  creates  a  smart  contract  execution  transaction.  If  the smart  contract  is  not  in  the  current  shard,  the  transaction  is treated as a payment transaction, the value of the transaction is  subtracted  from  the  sender  account  and  it  is  added  to the  block  where  the  sender  shard  resides,  into  a  miniblock with the destination shard where the receiver account is. The transaction  is  notarized  by  metachain,  then  processed  by  the destination  shard.  In  the  destination  shard,  the  transaction  is treated  as  SC  method  invoking,  as  the  receiver  address  is a  smart  contract  which  exists  in  this  shard.  For  the  smart contract  call  a  temporary  account  which  shadows  the  sender account is created, with the balance from the transaction value and  the  smart  contract  is  called.  After  the  execution,  the smart  contract  might  return  results  which  affects  a  number of accounts from different shards.</source>
        <target>L'approche d'Elrond à ce problème est d'utiliser le modèle d'exécution asynchrone des inter Shards pour le cas de Smart Contracts. L'utilisateur crée une transaction d'exécution de Smart Contract. Si le Smart Contract n'est pas dans le Shard courant, la transaction est traitée comme une opération de paiement, la valeur de la transaction est soustraite du compte émetteur et elle est ajoutée au bloc où réside le Shard émetteur, dans un minibloc avec le Shard de destination où se trouve le compte récepteur. La transaction est notariée par la métachaîne, puis traitée par le Shard de destination. Dans le Shard de destination, la transaction est traitée comme une méthode d'invocation de Smart Contract, car l'adresse du destinataire est un Smart Contract qui existe dans ce tesson. Pour l'appel de Smart Contract, un compte temporaire est créé, en tant qu'image du compte de l'expéditeur, avec le solde de la valeur de la transaction puis le Smart Contract est appelé. Après l'exécution, le Smart Contract peut renvoyer des résultats qui affectent un certain nombre de comptes de différents Shards.</target>
      </trans-unit>
      <trans-unit id="226" resname="f2e586d2fff07ac5bd393344ccdef794">
        <source>All the results, which affect in-shard  accounts  are  executed  in  the  same  round.  For  those accounts which are not in the shard where the smart contract was executed, transactions called Smart Contract Results will be  created,  saving  the  smart  contract  execution  output  for each of these accounts. SCR miniblocks are created for each destination  shard.  These  miniblocks  are  notarized  the  same way as cross-shard transactions by metachain, then processed by  the  respective  shards,  where  the  accounts  resides.  In  case one  smart  contract  calls  dynamically  another  smart  contract from another shard, this call is saved as an intermediate result and treated the same as for accounts.</source>
        <target>Tous les résultats, qui affectent des comptes à l'intérieur d'un même Shard, sont exécutés au cours du même tour. Pour les comptes qui ne sont pas dans le Shard où le Smart Contract a été exécuté, des transactions appelées &quot;Smart Contract Resultats&quot; seront créées, sauvegardant le résultat de l'exécution du Smart Contract pour chacun de ces comptes. Des miniblocs SCR sont créés pour chaque Shards de destination. Ces miniblocs sont notariés de la même manière que les transactions entre Shards par métachaîne, puis traités par les Shards respectifs, où se trouvent les comptes. Si un Smart Contract appelle dynamiquement un autre Smart Contract à partir d'un autre Shard, cet appel est enregistré comme résultat intermédiaire et traité de la même manière que pour les comptes.</target>
      </trans-unit>
      <trans-unit id="227" resname="4392ce964ab8a0307faea1a9dcb8ca3e">
        <source>The  solution  has  multiple  steps  and  the  finalization  of  a cross-shard smart contract call will need at least 5 rounds, but it does not need locking and state movement across shards.</source>
        <target>La solution se déroule en plusieurs étapes et la finalisation d'un appel de Smart Contract entre Shards nécessitera au moins 5 tours, mais elle ne requiert pas de verrouillage ni de propagation d'état à travers les Shards.</target>
      </trans-unit>
      <trans-unit id="228" resname="8b7393fd4ad0f1510f4d3114b31a6705">
        <source>IX  Bootstrapping and Storage</source>
        <target>IX Amorçage et stockage</target>
      </trans-unit>
      <trans-unit id="229" resname="b7fcd702bfdc96e0f6e218282ce26f9e">
        <source>1  Timeline division</source>
        <target>1 Division du calendrier</target>
      </trans-unit>
      <trans-unit id="230" resname="42618b2eb4da0eebb9e523f89d1d47d5">
        <source>Proof of Stake systems tend to generally divide timeline into epochs and each epoch into smaller rounds [19]. The timeline and terminology may differ between architectures but most of them use a similar approach.</source>
        <target>Les systèmes à preuve d'enjeu ont tendance à diviser la chronologie en époques et chaque époque en tours plus petits [19]. La chronologie et la terminologie peuvent varier d'une architecture à l'autre, mais la plupart d'entre elles utilisent une approche similaire.</target>
      </trans-unit>
      <trans-unit id="231" resname="5f612a7e5e32ee71f8e28f3a9b6413dd">
        <source>Epochs</source>
        <target>Les époques</target>
      </trans-unit>
      <trans-unit id="232" resname="33a134b71dbec6ef80086feb4749deca">
        <source>3In Elrond Protocol, each epoch has a fixed duration, initially set to 24 hours (might suffer updates after several testnet con- firmation stages). During this timeframe, the configuration of the shards remains unchanged. The system adapts to scalability demands between epochs by modifying the number of shards. To prevent collusion, after an epoch, the configuration of each shard  needs  to  change.  While  reshuffling  all  nodes  between shards would provide the highest security level, it would affect the system’s liveness by introducing additional latency due to bootstrapping. For this reason, at the end of each epoch, less than  1   of the eligible validators, belonging to a shard will be redistributed non-deterministically and uniformly to the other shards’ waiting lists.</source>
        <target>3 Dans le protocole Elrond, chaque époque a une durée fixe, initialement fixée à 24 heures (valeur susceptible d'évoluer après quelques étape de confirmation du testnet). Pendant cette période, la configuration des Shards reste inchangée. Le système s'adapte aux exigences de scalabilité entre les époques en modifiant le nombre de Shards. Pour éviter toute collusion, après une époque, la configuration de chaque Shards doit être modifiée. Un remaniement de tous les nœuds entre les Shards permettrait d'obtenir le niveau de sécurité le plus élevé, mais il affecterait la viabilité du système en introduisant une latence supplémentaire due à l'amorçage. C'est pourquoi, à la fin de chaque époque, moins d'un des validateurs éligibles appartenant à un Shard sera redistribué de manière non déterministe et uniforme sur les listes d'attente des autres Shards.</target>
      </trans-unit>
      <trans-unit id="233" resname="efc67d869b5ff9b80e015ff541b5e35a">
        <source>Only  prior  to  the  start  of  a  new  epoch,  the  validator distribution  to  shards  can  be  determined,  without  additional communication as displayed in Fig. 10.</source>
        <target>Ce n'est qu'avant le début d'une nouvelle époque que la distribution des validateurs aux Shards peut être déterminée, sans communication supplémentaire, comme le montre la figure 10.</target>
      </trans-unit>
      <trans-unit id="234" resname="5bd8b92688e75f54a9a5afcf8fa3f645">
        <source>The node shuffling process runs in multiple steps:</source>
        <target>Le processus de remaniement des nœuds se déroule en plusieurs étapes :</target>
      </trans-unit>
      <trans-unit id="235" resname="fc04bf1d7e7b0c79d55d358a89c90842">
        <source>1)  The  new  nodes  registered  in  the  current  epoch  ei   land in the unassigned node pool until the end of the current epoch;</source>
        <target>1) Les nouveaux nœuds enregistrés à l'époque courante ei atterrissent dans le pool de nœuds non attribués jusqu'à la fin de l'époque actuelle ;</target>
      </trans-unit>
      <trans-unit id="236" resname="ba7e7a030852bc2c5114966e7ae39d59">
        <source>6)  The  reshuffled  nodes  from  the  assigned  node  pool  are redistributed  with  higher  ratios  to  shards’  waiting  lists that will need to split in the next epoch ei+2.</source>
        <target>6) Les nœuds remaniés du pool de nœuds attribués sont redistribués avec des ratios plus élevés aux listes d'attente des Shards qui devront se séparer à la prochaine époque ei+2.</target>
      </trans-unit>
      <trans-unit id="237" resname="8de29ac877ff4eeb2ce259e84d677097">
        <source>Rounds</source>
        <target>Tours</target>
      </trans-unit>
      <trans-unit id="238" resname="23bce88395b716e84b9dcc138e75a6b5">
        <source>Each  round  has  a  fixed  time  duration  of  5  seconds  (might suffer updates after several testnet confirmation stages). During each round, a new block can be produced within every shard by a randomly selected set of block validators (including one block proposer). From one round to another the set is changed using the eligible nodes list, as detailed in the chapter IV.</source>
        <target>Chaque tour a une durée fixe de 5 secondes (peut subir des mises à jour après plusieurs étapes de confirmation testnet). Lors de chaque tour, un nouveau bloc peut être produit dans chaque partition par un ensemble de validateurs de blocs sélectionnés au hasard (y compris un proposant de blocs). D'un tour à l'autre, l'ensemble est modifié à l'aide de la liste des nœuds éligibles, comme indiqué dans le chapitre IV.</target>
      </trans-unit>
      <trans-unit id="239" resname="454477a6c6c4bfbf1d0321c688bd4dfa">
        <source>As  described  before,  the  reconfiguration  of  shards  within epochs and the arbitrary selection of validators within rounds discourages  the  creation  of  unfair  coalitions,  diminishes  the possibility  of  DDoS  and  bribery  attacks  while  maintaining decentralization and a high transactions throughput.</source>
        <target>Comme décrit précédemment, la reconfiguration des Shards au sein des époques et la sélection arbitraire des validateurs au sein des cycles découragent la création de coalitions injustes, diminuent la possibilité de DDoS et d'attaques de corruption tout en maintenant la décentralisation et un débit de transactions élevé.</target>
      </trans-unit>
      <trans-unit id="240" resname="cf3d19dd2f47cc4b58d279630416a2de">
        <source>2  Pruning</source>
        <target>2 Élagage</target>
      </trans-unit>
      <trans-unit id="241" resname="3877614027e2ab04d05a920e4707e544">
        <source>A   high   throughput   will   lead   to   a   distributed   ledger that  rapidly  grows  in  size  and  increases  bootstrapping  cost (time+storage), as highlighted in section XI.1.</source>
        <target>Un débit élevé conduira à un registre distribué qui croîtra rapidement en taille et augmentera le coût d'amorçage (temps+stockage), comme souligné dans la section XI.1.</target>
      </trans-unit>
      <trans-unit id="242" resname="b5787dffec9d81e95889e864129a716c">
        <source>This  cost  can  be  addressed  by  using  efficient  pruning algorithms, that can summarize the blockchain’s full state in a more condensed structure. The pruning mechanism is similar to  the  stable  checkpoints  in  pBFT  [15]  and  compresses  the entire ledger state.</source>
        <target>Ce coût peut être compensé par l'utilisation d'algorithmes d'élagage efficaces, qui peuvent résumer l'état complet de la BlockChain dans une structure plus condensée. Le mécanisme d'élagage est similaire aux points de contrôle stables de la pBFT [15] et compresse l'ensemble de l'état du livre..</target>
      </trans-unit>
      <trans-unit id="243" resname="f02ab335d2d34498c1f78f098fea49e7">
        <source>Elrond protocol makes use of an efficient pruning algorithm [7] detailed below. Let us consider that e is the current epoch and a is the current shard:</source>
        <target>Le protocole Elrond utilise un algorithme d'élagage performant [7] détaillé ci-dessous. Considérons que e est l'époque actuelle et que a est le Shard actuel :</target>
      </trans-unit>
      <trans-unit id="244" resname="baa09561482d5a9f20a6afff71d9ded0">
        <source>1)  the shard nodes keep track of the account balances of e in a Merkle tree [44];</source>
        <target>1) les nœuds de shards gardent une trace des soldes des comptes de e dans un arbre Merkle [44] ;</target>
      </trans-unit>
      <trans-unit id="245" resname="2163844b4a8c02b22f3ade1306a38309">
        <source>2)  at  the  end  of  each  epoch,  the  block  proposer  creates  a state block sb(a, e), which stores the hash of the Merkle tree’s root in the block’s header and the balances in the block’s body;</source>
        <target>2) à la fin de chaque époque, le proposant de bloc crée un bloc d'état sb(a, e), qui stocke le hachage de la racine de l'arbre Merkle dans l'en-tête du bloc et les soldes dans le corps du bloc ;</target>
      </trans-unit>
      <trans-unit id="246" resname="71e8e43ca3c3d79e1e57a209e8a00461">
        <source>3)  validators verify and run consensus on sb(a, e);</source>
        <target>3) les validateurs vérifient et exécutent le consensus sur sb(a, e) ;</target>
      </trans-unit>
      <trans-unit id="247" resname="d2fb87f96c99cc8b920b12486ecfb24a">
        <source>4)  if  consensus  is  reached,  the  block  proposer  will  store sb(a, e) in the shard’s ledger, making it the genesis block for epoch e + 1;</source>
        <target>4) si un consensus est atteint, le proposant du bloc stockera sb(a, e) dans le registre du Shard, ce qui en fera le bloc de genèse pour l'époque e + 1 ;</target>
      </trans-unit>
      <trans-unit id="248" resname="3fed06d6bc669eb866ed477c257a2958">
        <source>5)  at the end of epoch e + 1, nodes will drop the body of sb(a, e) and all blocks preceding sb(a, e).</source>
        <target>5) à la fin de l'époque e + 1, les nœuds feront tomber le corps de sb(a, e) et tous les blocs précédant sb(a, e).</target>
      </trans-unit>
      <trans-unit id="249" resname="0e274cd20775367fba5ace1972b8be19">
        <source>Using this mechanism, the bootstrapping of the new nodes should  be  very  efficient.  Actually,  they  start  only  from  the last  valid  state  block  and  compute  only  the  following  blocks instead of its full history.</source>
        <target>Grâce à ce mécanisme, l'amorçage des nouveaux nœuds devrait être très performant. En fait, ils ne partent que du dernier bloc d'état valide et ne calculent que les blocs suivants au lieu de son historique complet.</target>
      </trans-unit>
      <trans-unit id="250" resname="2005fa3c043b97850f5ebe4ae1094218">
        <source>32)  Less  than  1 of  the  nodes  in  every  shard  are randomly selected to be reshuffled and are added to the assigned node pool;</source>
        <target>2) Moins d'un tier (1/3) des nœuds de chaque shard sont sélectionnés aléatoirement pour être remaniés et ajoutés au pool de nœuds attribué ;</target>
      </trans-unit>
      <trans-unit id="251" resname="c95683f3a55bf2789f4313a8b203373f">
        <source>3)  The new number of shards Nsh,i+1  is computed based on the number of nodes in the network ki  and network usage;</source>
        <target> Le nouveau nombre de Shards Nsh,i+1 est calculé sur la base du nombre de nœuds dans le réseau ki et de l'utilisation du réseau ;</target>
      </trans-unit>
      <trans-unit id="252" resname="54bfc950f254e6d9116a8e58a35b5b94">
        <source>4)  Nodes previously in all shard’s waiting lists, that are cur- rently synchronized, are added to the eligible validator’s lists;</source>
        <target>Les nœuds précédemment présents dans toutes les listes d'attente de Shards, qui sont actuellement synchronisés, sont ajoutés aux listes des validateurs éligibles ;</target>
      </trans-unit>
      <trans-unit id="253" resname="4a9a422d575539298399f554195d2e8c">
        <source>5)  The newly added nodes from the unassigned node pool are   uniformly   random   distributed   across   all   shards’ waiting lists during epoch ei+1;</source>
        <target>Les nouveaux nœuds ajoutés à partir du pool de nœuds non attribués sont uniformément répartis de manière aléatoire sur toutes les listes d'attente des Shards pendant l'époque ei+1 ;</target>
      </trans-unit>
      <trans-unit id="254" resname="8847355771a424df6cfdaff4c5abd9ee">
        <source>X  Security Evaluation</source>
        <target>X Évaluation de la sécurité</target>
      </trans-unit>
      <trans-unit id="255" resname="1ba5896222f374e5068399d9613655bb">
        <source>1  Randomness source</source>
        <target>1 Source à caractère aléatoire</target>
      </trans-unit>
      <trans-unit id="256" resname="97a809955c8b114bfda7b2a247c2e73e">
        <source>Elrond makes use of random numbers in its operation e.g. for the random sampling of block proposer and validators into consensus  groups  and  the  shuffling  of  nodes  between  shards at  the  end  of  an  epoch.  Because  these  features  contribute to  Elrond’s  security  guarantees,  it  is  therefore  important  to make use of random numbers that are provably unbiasable and unpredictable.  In  addition  to  these  properties,  the  generation of random numbers also needs to be efficient so that it can be used in a scalable and high throughput blockchain architecture. These properties can be found in some asymmetric cryptog- raphy schemes, like the BLS signing scheme. One important property  of  BLS  is  that  using  the  same  private  key  to  sign the  same  message  always  produces  the  same  results.  This  is similar  to  what  is  achieved  using  ECDSA  with  </source>
        <target>Elrond utilise des nombres aléatoires dans son fonctionnement, par exemple pour l'échantillonnage aléatoire des proposants de blocs et des validateurs des groupes de consensus et le mélange des nœuds entre les Shards à la fin d'une époque. Étant donné que ces caractéristiques contribuent aux garanties de sécurité d'Elrond, il est donc important d'utiliser des nombres aléatoires qui sont manifestement imbiaisables et imprévisibles. En plus de ces propriétés, la génération de nombres aléatoires doit également être efficace afin qu'elle puisse être utilisée dans une architecture Blockchain évolutive et à haut débit. Ces propriétés peuvent être trouvées dans certains schémas cryptographiques asymétriques, comme le schéma de signature BLS. Une propriété importante de BLS est que l'utilisation de la même clé privée pour signer le même message produit toujours les mêmes résultats.  Ce résultat est similaire à celui obtenu avec l'ECDSA et sa génération déterministe k et il est dû au fait que le système n'utilise aucun paramètre aléatoire :</target>
      </trans-unit>
      <trans-unit id="257" resname="145f9ba9dcc6fd9caadcb2853b48b87d">
        <source>deterministic k generation and is due to the scheme not using any random parameters:</source>
        <target>[ABOVE]</target>
      </trans-unit>
      <trans-unit id="258" resname="9f870304948b11b904ac229f838a9938">
        <source>sig = sk · H(m)                                (8)</source>
        <target>sig = sk · H(m)                                (8)</target>
      </trans-unit>
      <trans-unit id="259" resname="f7c403db34e258e733735da76436fa0a">
        <source>where  H  is  a  hashing  function  that  hashes  to  points  on  the used curve and sk  is the private key.</source>
        <target>où H est une fonction de hashage qui hashe en points sur la courbe utilisée et sk est la clé privée.</target>
      </trans-unit>
      <trans-unit id="260" resname="dd0e55d8f6a9211a94b6005c2ae4cfed">
        <source>2  Randomness creation in Elrond</source>
        <target>2 Création à caractère aléatoire pour Elrond</target>
      </trans-unit>
      <trans-unit id="261" resname="615a9aacce81037517a80015e96e2f2c">
        <source>One  random  number  is  created  in  every  round,  and  added by the block proposer to every block in the blockchain. This ensures  that  the  random  numbers  are  unpredictable,  as  each random number is the signature of a different block proposer over the previous randomness source. The creation of random numbers is detailed below as part of one consensus round:</source>
        <target>Un nombre aléatoire est créé dans chaque tour, et ajouté par le promoteur de bloc à chaque bloc de la Blockchain. Cela garantit que les nombres aléatoires sont imprévisibles, car chaque nombre aléatoire est la signature d'un promoteur de bloc différent par rapport à la source aléatoire précédente. La création de nombres aléatoires est décrite ci-dessous dans le cadre d'un cycle de consensus :</target>
      </trans-unit>
      <trans-unit id="262" resname="695f791289d881560c9d929949f08051">
        <source>1)  New consensus group is selected using the randomness source from the previous block header. Consensus group is formed by a block proposer and validators.</source>
        <target>1) Le nouveau groupe de consensus est sélectionné à l'aide de la source de caractère aléatoire de l'en-tête de bloc précédent. Le groupe de consensus est formé par un promoteur de bloc et des validateurs.</target>
      </trans-unit>
      <trans-unit id="263" resname="eecb904bcf89cbbe263f067233010a7c">
        <source>2)  The   block   proposer   signs   the   previous   randomness source  with  BLS,  adds  the  signature  to  the  proposed block header as new randomness source, then broadcasts this block to the consensus group.</source>
        <target>2) Le proposant du bloc signe la source de caractère aléatoire précédente avec le BLS, ajoute la signature à l'en-tête du bloc proposé comme nouvelle source de caractère aléatoire, puis diffuse ce bloc au groupe de consensus.</target>
      </trans-unit>
      <trans-unit id="264" resname="f70846fc685cac9fd9dd69c4f530be71">
        <source>3)  Each  member  of  the  consensus  group  validates  the randomness source as part of block validation, and sends their block signature to the block proposer.</source>
        <target>3) Chaque membre du groupe de consensus valide la source de caractère aléatoire dans le cadre de la validation du bloc, et envoie sa signature de bloc au promoteur de bloc.</target>
      </trans-unit>
      <trans-unit id="265" resname="afb09c9314ec12459e025b0d32be84c5">
        <source>4)  Block  proposer  aggregates  the  validators  block  signa- tures and broadcasts the block with the aggregated block signature and the new randomness source to the whole shard.</source>
        <target>4) Le proposant de bloc agrège les signatures de bloc des validateurs et diffuse le bloc avec la signature de bloc agrégée et la nouvelle source de caractère aléatoire à l'ensemble de la shard.</target>
      </trans-unit>
      <trans-unit id="266" resname="9f38763c3a31ffb959fc368a263e6fd8">
        <source>The  evolution  of  randomness  source  in  each  round  can  be seen  as  an  unbiasable  and  verifiable  blockchain,  where  each new random number can be linked to and verified against the previous random number.</source>
        <target>L'évolution aléatoire de la source dans chaque cycle peut être considérée comme une blockchain non biaisée et vérifiable, où chaque nouveau nombre aléatoire peut être lié et vérifié par rapport au nombre aléatoire précédent.</target>
      </trans-unit>
      <trans-unit id="267" resname="7a28dac986ce0c4144d713a3de7e86a3">
        <source>3  ”K” block finality scheme</source>
        <target>3 Schéma de finalité du bloc &quot;K&quot;</target>
      </trans-unit>
      <trans-unit id="268" resname="a93538b11a512162c0ae8d6365e174f1">
        <source>33The signed block at round n is final, if and only if blocks n + 1, n + 2, ..., n + k  are signed. Furthermore, a final block cannot be reverted. The metachain notarizes only final blocks to ensure that a fork in one shard does not affect other shards. Shards only take into consideration the final metachain blocks, in order to not be affected if the metachain forks. Finality and correctness is verified at block creation and at block validation as  well.  The  chosen  k  parameter  is  1  and  this  ensures  forks of maximum 2 blocks length. The probability that a malicious super  majority  (&gt;  2  · n + 1)  is  selected  in  the  shard  for  the</source>
        <target>Le bloc signé au tour n est définitif, si et seulement si les blocs n + 1, n + 2, ..., n + k sont signés. En outre, un bloc final ne peut pas être annulé. La métachaîne ne notifie que les blocs finaux afin de garantir qu'une bifurcation dans une shard n'affecte pas les autres. Celles-ci ne prennent en considération que les blocs finaux de la métachaîne, afin de ne pas être affectés si elle se ramifie. La finalité et l'exactitude sont vérifiées lors de la création et de la validation des blocs. Le paramètre k choisi est 1, ce qui garantit des fourches d'une longueur maximale de 2 blocs. La probabilité qu'une super majorité malveillante (&gt; 2 - n + 1) soit sélectionnée dans le tesson pour le</target>
      </trans-unit>
      <trans-unit id="269" resname="d353ba0f1695081b19ea39a37e310049">
        <source>33same  round  in  the  same  consensus  is  10−9,  even  if  33%  of the nodes from the shard are malicious. In that case they can propose a block and sign it - let’s call it block  m, but it will not  be  notarized  by  the  metachain.  The  metachain  notarizes block m, only if block m + 1 is built on top of it. In order to create block m+1 the next consensus group has to agree with block m. Only a malicious group will agree with block m, so the  next  group  must  have  a  malicious  super  majority  again. As  the  random  seed  for  group  selection  cannot  be  tampered with,  the  probability  of  selecting  one  more  malicious  super majority  group  is    10−9   (5.38 ·  10−10,  to  be  exact).  The probability of signing two consecutive malicious blocks equals with selecting two subgroups with at least (2 · n+1) members from  the  malicious  group  consequently.  The  probability  for this is   10−18. Furthermore, the consequently selected groups must be colluding, otherwise the blocks will not be signed.</source>
        <target>Le même tour dans le même consensus est de 10-9, même si 33% des nœuds de la shard sont malveillants. Dans ce cas, ils peuvent proposer un bloc et le signer - appelons-le bloc m-, mais il ne sera pas notarié par la métachaîne. La métachaîne ne notifie le bloc m que si le bloc m + 1 est construit par-dessus. Afin de créer le bloc m+1, le groupe de consensus suivant doit être d'accord avec le bloc m. Seul un groupe malveillant sera d'accord avec le bloc m, donc le groupe suivant doit à nouveau avoir une super majorité malveillante. Comme la séquence aléatoire pour la sélection du groupe ne peut être modifiée, la probabilité de sélectionner un autre groupe super majoritaire malveillant est de 10-9 (5,38 - 10-10, pour être exact). La probabilité de signer deux blocs malveillants consécutifs est égale à la sélection de deux sous-groupes comportant au moins (2 - n+1) membres du groupe malveillant en conséquence. La probabilité pour cela est de 10-18. En outre, les groupes sélectionnés en conséquence doivent être de connivence, sinon les blocs ne seront pas signés.</target>
      </trans-unit>
      <trans-unit id="270" resname="71bd0345c2c1cb692a11393b76224974">
        <source>4  Fisherman challenge</source>
        <target>4 Le défi du pêcheur</target>
      </trans-unit>
      <trans-unit id="271" resname="b39bf2726c568937d389cae62fee7f8e">
        <source>When one invalid block is proposed by a malicious majority, the  shard  state  root  is  tampered  with  an  invalid  result  (after including invalid changes to the state tree). By providing the combined  merkle  proof  for  a  number  of  accounts,  an  honest node could raise a challenge with a proof. The honest nodes will  provide  the  block  of  transactions,  the  previous  reduced merkle  tree  with  all  affected  accounts  before  applying  the challenged  block  and  the  smart  contract  states,  thus  demon- strating the invalid transaction / state. If a challenge with the proof  is  not  provided  in  the  bounded  time  frame,  the  block is  considered  valid.  The  cost  of  one  invalid  challenge  is  the entire stake of the node which raised the challenge.</source>
        <target>Lorsqu'un bloc invalide est proposé par une majorité malveillante, la racine de l'état de la shard est altérée avec un résultat invalide (après avoir inclus des modifications invalides à l'arbre d'état). En fournissant la preuve du merkle combiné pour un certain nombre de comptes, un nœud honnête pourrait soulever un défi avec une preuve. Les nœuds honnêtes fourniront le bloc de transactions, l'arbre de merkle réduit précédent avec tous les comptes affectés avant d'appliquer le bloc contesté et les états de contrat intelligents, ce qui permet de démonter la transaction/état invalide. Si une contestation avec la preuve n'est pas fournie dans le délai imparti, le bloc est considéré comme valide. Le coût d'une contestation non valable correspond à la totalité de l'enjeu du nœud qui a soulevé la contestation.</target>
      </trans-unit>
      <trans-unit id="272" resname="224c4bea75908a97bc4550a3431c7531">
        <source>The  metachain  detects  the  inconsistency,  either  an  invalid transaction,  or  an  invalid  state  root,  through  the  presented challenges  and  proofs.  This  can  be  traced  and  the  consensus group can be slashed. At the same time the challenger can be rewarded  with  part  of  the  slashed  amount.  Another  problem is when a malicious group hides the invalid block from other nodes - non-malicious ones. However, by making it mandatory for the current consensus to propagate the produced block to the  sibling  shard  and  to  the  observer  nodes,  the  data  cannot be  hidden  anymore.  The  communication  overhead  is  further reduced by sending only the intrashard miniblock to the sibling shard. The cross shard miniblocks are always sent on different topics  accessible  by  interested  nodes.  In  the  end,  challenges can be raised by multiple honest nodes. Another security pro- tection is given by the setup of P2P topics. The communication from one shard toward the metachain is done through a defined set  of  topics  /  channels,  which  can  be  listened  to  by  any honest  validator  -  the  metachain  will  not  accept  any  other messages from other channels. This solution introduces some delay in the metachain only in case of challenges, which are very  low  in  number  and  highly  improbable  since  if  detected (high probability of being detected) the nodes risk their entire stake. </source>
        <target>La métachaîne détecte l'incohérence, soit une transaction non valide, soit une racine d'état non valide, grâce aux défis et aux preuves présentés. Elle permet de remonter à la source de l'incohérence et de réduire le groupe de consensus. Dans le même temps, le challenger peut être récompensé par une partie du montant réduit. Un autre problème se pose lorsqu'un groupe malveillant cache le bloc invalide à d'autres nœuds - non malveillants. Cependant, en rendant obligatoire, dans le cadre du consensus actuel, la propagation du bloc produit aux shards soeurs et aux nœuds observateurs, les données ne peuvent plus être cachées. La surcharge de communication est encore réduite en n'envoyant que le minibloc intrasecret aux shards soeurs. Les miniblocs transversaux sont toujours envoyés sur différents sujets accessibles par les nœuds intéressés. En fin de compte, les défis peuvent être relevés par plusieurs nœuds honnêtes. La mise en place de sujets P2P constitue une autre mesure de sécurité. La communication d'une shard vers la métachaîne se fait par un ensemble défini de sujets / canaux, qui peuvent être écoutés par n'importe quel validateur honnête - la métachaîne n'acceptera aucun autre message provenant d'autres canaux. Cette solution introduit un certain retard dans la métachaîne uniquement en cas de sharding, qui sont très peu nombreux et très improbables car, s'ils sont détectés (forte probabilité d'être détectés), les tessons risquent de perdre tout leur enjeu. </target>
      </trans-unit>
      <trans-unit id="273" resname="80502c1bf6b403c8cfba897bff506667">
        <source>5  Shard reorganization</source>
        <target>5 réorganisation des shards</target>
      </trans-unit>
      <trans-unit id="274" resname="af2a12cadfb82f506616fc41a59ef8dd">
        <source>33After  each  epoch,  less  than  1  · n  of  the  nodes  from  each shard  are  redistributed  uniformly  and  non-deterministically across the other shards, to prevent collusion. This method adds bootstrapping overhead for the nodes that were redistributed, but doesn’t affect liveness as shuffled nodes do not participate in  the  consensus  in  the  epoch  they  have  been  redistributed. The  pruning  mechanism  will  decrease  this  time  to  a  feasible amount, as explained in section IX.2.</source>
        <target>Après chaque époque, moins de 1 . n des nœuds de chaque shards sont redistribués de manière uniforme et non déterministe sur les autres tessons, afin d'éviter toute collusion. Cette méthode ajoute un surcoût d'amorçage pour les nœuds qui ont été redistribués, mais n'affecte pas la qualité de vie car les nœuds remaniés ne participent pas au consensus de l'époque à laquelle ils ont été redistribués. Le mécanisme d'élagage diminuera cette fois-ci jusqu'à un montant réalisable, comme expliqué dans la section IX.2.</target>
      </trans-unit>
      <trans-unit id="275" resname="d1457a71ecc2b1967d1bfea2ca8c7cfc">
        <source>6  Consensus group selection</source>
        <target>6 Sélection du groupe de consensus</target>
      </trans-unit>
      <trans-unit id="276" resname="31a29fe59c3bd858cffd8e4fb9276cb4">
        <source>After each round a new set of validators are selected using the random seed of the last commited block, current round and the  eligible  nodes  list.  In  case  of  network  desynchronization due  to  the  delays  in  message  propagation,  the  protocol  has a  recovery  mechanism,  and  takes  into  consideration  both  the round  r  and  the  randomness  seed  from  the  last  committed block  in  order  to  select  new  consensus  groups  every  round. This avoids forking and allows synchronization on last block. The small time window (round time) in which the validators</source>
        <target>Après chaque tour, un nouvel ensemble de validateurs est sélectionné en utilisant la graine aléatoire du dernier bloc validé, le tour en cours et la liste des nœuds éligibles. En cas de désynchronisation du réseau due à des retards dans la propagation des messages, le protocole dispose d'un mécanisme de récupération, et prend en considération à la fois le cycle r et la semence aléatoire du dernier bloc validé afin de sélectionner de nouveaux groupes de consensus à chaque cycle. Cela évite les bifurcations et permet la synchronisation sur le dernier bloc. La petite fenêtre de temps (temps de ronde) dans laquelle les validateurs</target>
      </trans-unit>
      <trans-unit id="277" resname="1fc9231858c9d9a56eefc42f48a5a613">
        <source>group is known, minimizes the attack vectors.</source>
        <target>est connu, minimise les vecteurs d'attaque.</target>
      </trans-unit>
      <trans-unit id="278" resname="145b7afb6838d8645c33286c7da2fad6">
        <source>7  Node rating</source>
        <target>7 Evaluation des nœuds</target>
      </trans-unit>
      <trans-unit id="279" resname="da5dd1f67f6215d89e6d90c9c8414e6f">
        <source>Beside  stake,  the  eligible  validator’s  rating  influences  the chances to be selected as part of the consensus group. If the block proposer is honest and its block gets committed to the blockchain,  it  will  have  its  rating  increased,  otherwise,  it’s rating  will  be  decreased.  This  way,  each  possible  validator is  incentivized  to  be  honest,  run  the  most  up-to-date  client software  version,  increase  its  service  availability  and  thus ensuring the network functions as designed.</source>
        <target>Outre l'enjeu, la notation du validateur éligible influence les chances d'être sélectionné dans le cadre du groupe de consensus. Si le ppromoteur de bloc est honnête et que son bloc s'engage dans la Blockchain, sa note sera augmentée, sinon, sa note sera diminuée. De cette façon, chaque validateur possible est incité à être honnête, à utiliser la version la plus récente du logiciel client, à augmenter sa disponibilité de service et à assurer ainsi que le réseau fonctionne comme prévu.</target>
      </trans-unit>
      <trans-unit id="280" resname="6b6d290f6775630189052425f2991dce">
        <source>8  Shard redundancy</source>
        <target>8 La redondance des fragments (shards)</target>
      </trans-unit>
      <trans-unit id="281" resname="abfc3a15687efd1291685293c73891cc">
        <source>The  nodes  that  were  distributed  in  sibling  shards  on  the tree’s lowest level (see section IV.4) keep track of each other’s blockchain  data  and  application  state.  By  introducing  the concept  of  shard  redundancy,  when  the  number  of  nodes  in the  network  decreases,  some  of  the  sibling  shards  will  need to  be  merged.  The  targeted  nodes  will  instantly  initiate  the process of shard merging.</source>
        <target>Les nœuds qui ont été distribués en tessons de frères et sœurs au niveau le plus bas de l'arbre (voir section IV.4) gardent la trace des données de la Blockchain et de l'état de l'application de chacun. En introduisant le concept de redondance des shards, lorsque le nombre de nœuds dans le réseau diminue, certaines des shards soeurs devront être fusionnés. Les nœuds ciblés lanceront instantanément le processus de fusion des shards.</target>
      </trans-unit>
      <trans-unit id="282" resname="809421d00f8065cef5b139556f2a2a3f">
        <source>XI  Understanding the real problems</source>
        <target>XI Comprendre les vrais problèmes</target>
      </trans-unit>
      <trans-unit id="283" resname="216c49098c3a139d16f1eab80287c10e">
        <source>1  Centralized vs Decentralized</source>
        <target>1 Centralisé vs Décentralisé</target>
      </trans-unit>
      <trans-unit id="284" resname="4de5bf66ce9dded373a51ab7b0506f8d">
        <source>Blockchain  was  initially  instantiated  as  an  alternative  to the  centralized  financial  system  of  systems  [45].  Even  if  the freedom and anonymity of distributed architectures remains an undisputed advantage, the performance has to be analyzed at a global scale in a real-world environment.</source>
        <target>La blockchain a été initialement instanciée comme alternative au système financier centralisé des systèmes [45]. Même si la liberté et l'anonymat des architectures distribuées restent un avantage incontesté, les performances doivent être analysées à l'échelle mondiale dans un environnement réel.</target>
      </trans-unit>
      <trans-unit id="285" resname="42faedc8b0ee396aabdb0e9b3c423028">
        <source>The most relevant metric measuring performance is transac-</source>
        <target>La mesure la plus pertinente de la performance est le nombre de transactions par seconde (TPS), comme le montre le tableau 2. Une comparaison des transactions par seconde entre les systèmes centralisés traditionnels et les nouvelles architectures décentralisées, dont la fiabilité et l'efficacité ont été validées à grande échelle, reflète une réalité objective mais troublante [46], [47], [48], [49]</target>
      </trans-unit>
      <trans-unit id="286" resname="3fb7424558ac7143a9c03053cdbce067">
        <source>tions per second (TPS), as seen in Table 2. A TPS comparison of  traditional  centralized  systems  with  decentralized  novel architectures  that  were  validated  as  trusted  and  efficient  on a  large  scale,  reflects  an  objective  yet  unsettling  reality  [46], [47], [48], [49].</source>
        <target>[ABOVE]</target>
      </trans-unit>
      <trans-unit id="287" resname="11587c99d590a264786d81d4f8b98425">
        <source>The  scalability  of  blockchain  architectures  is  a  critical</source>
        <target>La scalabilité des architectures en BlockChains est un problème critique mais toujours non résolu. Prenons, par exemple, l'exemple de la détermination des implications en matière de stockage des données et de bootstrapping des architectures de blockchain actuelles qui se mettraient soudainement à fonctionner au même niveau de débit que Visa. En procédant à de tels exercices, l'ampleur des multiples problèmes secondaires devient évidente (voir la figure 11).</target>
      </trans-unit>
      <trans-unit id="288" resname="c6ac0f38c565427d55bb1472e87c6629">
        <source>but  still  unsolved  problem.  Take,  for  instance,  the  example determining the data storage and bootstrapping implications of current blockchain architectures suddenly functioning at Visa level throughput. By performing such exercises, the magnitude of  multiple  secondary  problems  becomes  obvious  (see  Fig.</source>
        <target>&lt;Voir 287&gt;</target>
      </trans-unit>
      <trans-unit id="289" resname="c88abcc81b6b55e9d19106e6ed3298be">
        <source>11).</source>
        <target>&lt;voir 287&gt;</target>
      </trans-unit>
      <trans-unit id="290" resname="c0d0a5710ab6ecdd8e4287d8935000f4">
        <source>XII  The blockchain performance paradigm</source>
        <target>XII Le paradigme de performance blockchain</target>
      </trans-unit>
      <trans-unit id="291" resname="3e88a44c22100e5ceb6ac44056863ab5">
        <source>The  process   of   designing   distributed   architectures   on blockchain faces several challenges, perhaps one of the most challenging  being  the  struggle  to  maintain  operability  under contextual  pressure  conditions.  The  main  components  that determine the performance pressure are:</source>
        <target>Le processus de conception d'architectures distribuées sur Blockchain fait face à plusieurs défis, peut-être l'un des plus difficiles étant la lutte pour maintenir l'opérabilité dans des conditions de pression propres au contexte. Les principaux composants qui déterminent la pression de performance sont :</target>
      </trans-unit>
      <trans-unit id="292" resname="314a097f49568e5965d3eebec04fe4f0">
        <source>•   complexity</source>
        <target>• complexité</target>
      </trans-unit>
      <trans-unit id="293" resname="d8242f50c60e5a9c6c47298d0acab027">
        <source>•   system size</source>
        <target>• taille du système</target>
      </trans-unit>
      <trans-unit id="294" resname="71eb33336c934da65c4750acf362cf99">
        <source>•   transaction volume</source>
        <target>• volume des transactions</target>
      </trans-unit>
      <trans-unit id="295" resname="cafb3b8ae261a16c13b7440e6d5b5647">
        <source>Complexity</source>
        <target>Complexité</target>
      </trans-unit>
      <trans-unit id="296" resname="e33b06c9c5779a04b70d00c1b064e756">
        <source>The first element that limits the system performance, is the consensus protocol. A more complicated protocol determines a bigger hotspot. In PoW consensus architectures a big perfor- mance penalty is induced by the mining complexity that aims to keep the system decentralized and ASIC resilient [50]. To overrun  this  problem  PoS  makes  a  trade-off,  simplifies  the network  management  by  concentrating  the  computing  power to a subset of the network, but yields more complexity on the control mechanism.</source>
        <target>Le premier élément qui limite les performances du système, est le protocole de consensus. Un protocole plus compliqué détermine un point critique plus gros. Dans les architectures consensuelles de PoW, une grande pénalité de performance est induite par la complexité de l'exploitation qui vise à maintenir le système décentralisé et la résilience des ASIC [50]. Pour surmonter ce problème, le PoS fait un compromis, simplifie la gestion du réseau en concentrant la puissance de calcul sur un sous-ensemble du réseau, mais apporte plus de complexité au mécanisme de contrôle.</target>
      </trans-unit>
      <trans-unit id="297" resname="6ef9997134d1bc7624c4ebe08d7df6c2">
        <source>Archi- tecture</source>
        <target>Architecture</target>
      </trans-unit>
      <trans-unit id="298" resname="a9995a078e25fc38ce9b0ae277ffea0b">
        <source>Type              Dispersion</source>
        <target>Type  Dispersion</target>
      </trans-unit>
      <trans-unit id="299" resname="d99db8ad90b8a7d877dcda5fcad5e0dd">
        <source>Distributed</source>
        <target>Distribué</target>
      </trans-unit>
      <trans-unit id="300" resname="500b78340d2df6eecdaf946c14de998c">
        <source>TPS (average)</source>
        <target>TPS (moyenne)</target>
      </trans-unit>
      <trans-unit id="301" resname="cc5b90427401dfc6bcdbb43ab0f1cdb4">
        <source>TPS (max limit)</source>
        <target>TPS (limite maximale)</target>
      </trans-unit>
      <trans-unit id="302" resname="7b0116c6b0b32ef840628658721c398f">
        <source>System size</source>
        <target>Taille du système</target>
      </trans-unit>
      <trans-unit id="303" resname="dfee3f25fb3dac2084d5ff38338e01ea">
        <source>Expanding the number of nodes in existing validated architectures forces a serious performance degradation and induces</source>
        <target>L'augmentation du nombre de nœuds dans les architectures validées existantes entraîne une grave dégradation des performances et induit</target>
      </trans-unit>
      <trans-unit id="304" resname="61215cb3f7f02fac7c2eaf6b2f9b32dc">
        <source>VISA</source>
        <target>VISA</target>
      </trans-unit>
      <trans-unit id="305" resname="c5e2ed775c0b8923da33c33162d91292">
        <source>Paypal Ripple NEO Ethereum Bitcoin</source>
        <target>Paypal Ripple NEO Ethereum Bitcoin</target>
      </trans-unit>
      <trans-unit id="306" resname="70d424c21487d47bc7477c8c4d7db43a">
        <source>virtualization</source>
        <target>virtualisation</target>
      </trans-unit>
      <trans-unit id="307" resname="7091ece62eeb5f90bbdf46ee888358ba">
        <source>Distributed virtualization Private Blockchain Private Blockchain Public Blockchain Public</source>
        <target>Virtualisation distribuée Blockchain privée Blockchain privé publique Blockchain publique</target>
      </trans-unit>
      <trans-unit id="308" resname="6eadad8b0e4de60b58351a2e994440dd">
        <source>Blockchain</source>
        <target>Blockchain</target>
      </trans-unit>
      <trans-unit id="309" resname="1df899d38fe06b0f30ab4dbf0a443511">
        <source>Centralized            3500                55000</source>
        <target>Centralisé 3500 55000</target>
      </trans-unit>
      <trans-unit id="310" resname="6e9753e820f44f99236aa1b6ac0d1f84">
        <source>Centralized             200                   450</source>
        <target>Centralisé 200 450</target>
      </trans-unit>
      <trans-unit id="311" resname="37d508fd99fa037fcfd05210309cbcc0">
        <source>Permissioned          1500                55000</source>
        <target>Avec permission 1500 55000</target>
      </trans-unit>
      <trans-unit id="312" resname="b55dfb78b4b19a278e394c64e64145b3">
        <source>Mixed                1000                10000</source>
        <target>Mixte 1000 10000</target>
      </trans-unit>
      <trans-unit id="313" resname="573edc604df12d04345ed698211d9c31">
        <source>Decentralized            15                     25</source>
        <target>Décentralisé 15 25</target>
      </trans-unit>
      <trans-unit id="314" resname="7f5f1c9918ed5be6709d06944e3a047f">
        <source>Decentralized             2                       7</source>
        <target>Décentralisé 2 7</target>
      </trans-unit>
      <trans-unit id="315" resname="2f35aec1f3f5523e7d074d2d0eb877ad">
        <source>a higher  computational  price  that  must  be  paid.  Sharding seems  to  be  a  good  approach,  but  the  shard  size  plays  a major  role.  Smaller  shards  are  agile  but  more  likely  to  be affected by malicious groups, bigger shards are safer, but their reconfiguration affects the system liveness.</source>
        <target>un prix de calcul plus élevé qui doit être payé. Les Shards semblent être une bonne approche, mais la taille des Shards joue un rôle majeur. Les Shards plus petits sont agiles mais plus susceptibles d'être affectés par des groupes malveillants, les Shards plus gros sont plus sûrs, mais leur reconfiguration affecte la viabilité du système.</target>
      </trans-unit>
      <trans-unit id="316" resname="3fd4e4230d7e9bf41f6e603eb410da8f">
        <source>Transaction volume</source>
        <target>Transaction volume</target>
      </trans-unit>
      <trans-unit id="317" resname="1d5e9c779da281dff6e2546dd1bb8175">
        <source>With a higher relevance compared to the others, the last item on the list represents the transaction processing performance. In  order  to  correctly  measure  the  impact  of  this  criteria,  this must be analyzed considering the following two standpoints:</source>
        <target>Plus pertinent que les autres, le dernier élément de la liste concerne les performances de traitement des transactions. Afin de mesurer correctement l'impact de ce critère, celui-ci doit être analysé selon les deux points de vue suivants :</target>
      </trans-unit>
      <trans-unit id="318" resname="e5eee2cc9e3084af8c8409adbea7d345">
        <source>TABLE 2: Centralized vs Decentralized TPS comparison</source>
        <target>TABLEAU 2 : Comparaison des TPS entre une architecture centralisée et décentralisée</target>
      </trans-unit>
      <trans-unit id="319" resname="fcd09e45eb30655c94812d4a78ecb595">
        <source>•   C1  transaction  throughput  -  how  many  transactions  a system  can  process  per  time  unit,  known  as  TPS,  an output of a system [51];</source>
        <target>C1 Débit des transactions - combien de transactions un système peut traiter par unité de temps, connue sous le nom de TPS, en sortie d'un système donné [51] ;</target>
      </trans-unit>
      <trans-unit id="320" resname="7bd619172f6e88755238311212870caa">
        <source>•   C2  transaction  finality  -  how  fast  one  particular  trans- action  is  processed,  referring  to  the  interval  between  its launch and its finalization - an input to output path.</source>
        <target>- C2 Finalité de la transaction - la vitesse à laquelle une action particulière est traitée, en se référant à l'intervalle entre son lancement et sa finalisation - depuis l'entrée vers la sortie.</target>
      </trans-unit>
      <trans-unit id="321" resname="294fa51c7e5f078e17bafeadd76bd6a6">
        <source>C1. T ransaction throughput in single chain architectures is very  low  and  can  be  increased  by  using  workarounds  such as  sidechain  [52].  In  a  sharded  architecture  like  ours,  the transaction throughput is influenced by the number of shards, the  computing  capabilities  of  the  validators/block  proposers and the messaging infrastructure [8]. In general, as displayed in  Fig.  13,  this  goes  well  to  the  public,  but  despite  the importance of the metric, it provides only a fragmented view. C2.  T ransaction finality  -  A  more  delicate  aspect  that emphasizes that even if the system may have a throughput of 1000 TPS, it may take a while to process a particular transac- tion. Beside the computing capabilities of the validators/block proposers  and  the  messaging  infrastructure,  the  transaction finality is mainly affected by the dispatching algorithm (when the decision is made) and the routing protocol (where should the transaction be executed). Most of the existing state of the art architectures refuse to mention this aspect but from a user standpoint  this  is  extremely  important.  This  is  displayed  in</source>
        <target>C1. Le débit de transactions dans les architectures à chaîne unique est très faible et peut être augmenté en utilisant des solutions de contournement telles que la chaîne latérale [52]. Dans une architecture en Shards comme la nôtre, le débit de transaction est influencé par le nombre de Shards, les capacités de calcul des validateurs/proposeurs de blocs et l'infrastructure de messagerie [8]. En général, comme le montre la figure 13, cela va bien au public, mais malgré l'importance de la métrique, cela ne donne qu'une vue fragmentée. C2. Finalité de la transaction - Un aspect plus délicat qui souligne que même si le système peut avoir un débit de 1000 TPS, il peut prendre un certain temps pour traiter une transaction particulière. Outre les capacités de calcul des validateurs/proposeurs de bloc et l'infrastructure de messagerie, la finalité de la transaction est principalement affectée par l'algorithme de répartition (lorsque la décision est prise) et le protocole de routage (où la transaction doit-elle être exécutée). La plupart des architectures de pointe existantes refusent de mentionner cet aspect, mais du point de vue de l'utilisateur, il est extrêmement important. C'est ce qu'illustre la figure 14, où le temps total nécessaire pour exécuter une certaine transaction du début à la fin est pris en compte.</target>
      </trans-unit>
      <trans-unit id="322" resname="4e6f12283c346cb81a083a5dcc87ef9d">
        <source>Fig. 11: Storage Estimation - Validated distributed architectures working at an average of VISA TPS</source>
        <target>Fig. 11 : Estimation du stockage - Architectures distribuées validées pour un fonctionnant à une moyenne du TPS VISA</target>
      </trans-unit>
      <trans-unit id="323" resname="38bd79d30daf72fb75633ff64e2f632b">
        <source>Fig. 13: Transaction throughput</source>
        <target>Fig. 13 : Débit des transactions</target>
      </trans-unit>
      <trans-unit id="324" resname="717ffc6884b114da61548332528d207d">
        <source>Fig.  14,  where  the  total  time  required  to  execute  a  certain transaction from start to end is considered.</source>
        <target>&lt;cf 321&gt;</target>
      </trans-unit>
      <trans-unit id="325" resname="6381a9996e37fa33bcfacd1da5ad4697">
        <source>In Elrond, the dispatching mechanism (detailed in section V) allows an improved time to finality by routing the transactions directly to the right shard, mitigating the overall delays.</source>
        <target>À Elrond, le mécanisme de répartition (détaillé dans la section V) permet d'améliorer le délai de traitement en acheminant les transactions directement vers le bon tesson, ce qui réduit les délais globaux.</target>
      </trans-unit>
      <trans-unit id="326" resname="82fb09f3048dac7499c319383ab75640">
        <source>XIII  Conclusion</source>
        <target>XIII Conclusion</target>
      </trans-unit>
      <trans-unit id="327" resname="2d3c6337bdf13909643572712c6015e7">
        <source>1  Performance</source>
        <target>1 Performance</target>
      </trans-unit>
      <trans-unit id="328" resname="d2a34ef4b7bf1726bc5eb37b40555f90">
        <source>Performance  tests  and  simulations,  presented  in  Fig.  12, reflect  the  efficiency  of  the  solution  as  a  highly  scalable distributed ledger. As more and more nodes join the network our sharding approach shows a linearly increasing throughput. The chosen consensus model involves multiple communication rounds,  thus  the  result  is  highly  influenced  by  the  network quality  (speed,  latency,  availability).  Simulations  using  our testnet  using  worldwide  network  speed  averages,  at  its  max- imum  theoretical  limit,  suggest  Elrond  exceeds  the  average VISA  level  with  just  2  shards,  and  approaches  peak  VISA level with 16 shards.</source>
        <target>Les tests et simulations de performance, présentés à la figure 12, reflètent l'efficacité de la solution en tant que registre distribué hautement scalable. Comme de plus en plus de nœuds rejoignent le réseau, notre approche de Sharding démontre une augmentation linéaire du débit. Le modèle de consensus choisi implique de multiples tours de communication, le résultat est donc fortement influencé par la qualité du réseau (vitesse, latence, disponibilité). Les simulations réalisées avec notre testnet en utilisant les moyennes de vitesse du réseau mondial, à sa limite théorique maximale, suggèrent qu'Elrond dépasse le niveau VISA moyen avec seulement 2 Shards, et se rapproche du niveau VISA maximum avec 16 Shards.</target>
      </trans-unit>
      <trans-unit id="329" resname="f798cb32fd4e2cd1f3eedd87a15c386e">
        <source>Fig. 14: Transaction finality</source>
        <target>Fig. 14 : Finalité de la transaction</target>
      </trans-unit>
      <trans-unit id="330" resname="8e9f686a1a6766fa2ce4a0626cdcc7a3">
        <source>2  Ongoing and future research</source>
        <target>Recherche actuelle et future</target>
      </trans-unit>
      <trans-unit id="331" resname="d56ef801d62b522942a96f4c621e2997">
        <source>Our team is constantly re-evaluating and improving Elrond’s design,  in  an  effort  to  make  this  one  of  the  most  com- pelling public blockchain architectures; solving scalability via adaptive  state  sharding,  while  maintaining  security  and  high energy  efficiency  through  a  secure  Proof  of  Stake  consensus mechanism.  Some  of  our  next  directions  of  improvement include:</source>
        <target>Notre équipe réévalue et améliore constamment la conception d'Elrond, afin d'en faire l'une des architectures de BlockChain publique des plus prometteuses ; elle résout le problème de la sclabilité par le Sharding d'état adaptatif, tout en maintenant la sécurité et une haute efficacité énergétique grâce à un mécanisme sécurisé de consensus de preuve d'enjeux. Voici quelques-unes de nos prochaines orientations en matière d'amélioration :</target>
      </trans-unit>
      <trans-unit id="332" resname="4a5eec57976613a2e84b66a399149e4d">
        <source>1)  Reinforcement  learning:  we  aim  to  increase  the  efficiency  of  the  sharding  process  by  allocating  the  frequently  trading  clients  in  the  same  shard  to  reduce  the overall cost;</source>
        <target>1) Renforcement de l'apprentissage : nous visons à accroître l'efficacité du processus de Sharding en répartissant les clients qui négocient fréquemment dans le même Shard afin de réduire le coût global ;</target>
      </trans-unit>
      <trans-unit id="333" resname="a40d1781fa1a95e56c81a949b9cd6697">
        <source>2)  AI  supervision:  create  an  AI  supervisor  that  detects malicious  behavioral  patterns;  it  is  still  uncertain  how this  feature  can  be  integrated  in  the  protocol  without disrupting the decentralization;</source>
        <target>2) IA pour la supervision : créer un superviseur en IA qui détecte les modèles de comportement malveillant ; on ne sait pas encore comment cette fonctionnalité peut être intégrée dans le protocole sans perturber la décentralisation ;</target>
      </trans-unit>
      <trans-unit id="334" resname="8064e1454cf70b2f36645cd49af64b9b">
        <source>3)  Reliability as a consensus factor: the existing protocol weighs  between  stake  and  rating  but  we  plan  to  add reliability,  as  a  metric  that  should  be  computed  in  a distributed  manner  after  applying  a  consensus  protocol on  previously  submitted  blocks  from  the  very  recent</source>
        <target>3) Fiabilité en tant que facteur de consensus : le protocole existant pondère entre l'enjeu (staking) et la notation (rating), mais nous prévoyons d'ajouter la fiabilité, comme une mesure qui devrait être calculée de manière distribuée après l'application d'un protocole de consensus sur les blocs précédemment soumis récemment.</target>
      </trans-unit>
      <trans-unit id="335" resname="c5bc8c850dfe0b1ec002da5b009785eb">
        <source>Fig. 12: Network throughput measured in transactions per seconds with a global network speed of 8 MB/s</source>
        <target>Fig. 12 : Débit réseau mesuré en transactions par seconde avec une vitesse globale sur le réseau de 8 Mo/s</target>
      </trans-unit>
      <trans-unit id="336" resname="3737f3bd55c08232f80f0996aaee3edc">
        <source>history;</source>
        <target>l'histoire;</target>
      </trans-unit>
      <trans-unit id="337" resname="79dc34ec66b0da3fd80162e5a71aa65a">
        <source>4)  Cross-chain   interoperability:   implements   and   con- tribute   to  standards   like   those  initiated   by  the   De- centralized  Identity  Foundation  [53]  or  the  Blockchain Interoperability Alliance [54];</source>
        <target>4) interopérabilité inter-blockchain : mettre en œuvre et rendre hommage à des normes telles que celles lancées par la Decentralized Identity Foundation [53] ou la Blockchain Interoperability Alliance [54] ;</target>
      </trans-unit>
      <trans-unit id="338" resname="bb3b88390f1c98eb145ff8962c9fb931">
        <source>5)  Privacy preserving transactions: use Zero-Knowledge Succinct  Non-Interactive  Argument  of  Knowledge  [55] to  protect  the  identity  of  the  participants  and  offer auditing capabilities while preserving the privacy.</source>
        <target>5) Transactions préservant la vie privée : utiliser le &quot;Zero-Knowledge Succinct Non-Interactive Argument of Knowledge&quot; [55] pour protéger l'identité des participants et offrir des capacités d'audit tout en préservant la vie privée.</target>
      </trans-unit>
      <trans-unit id="339" resname="a729da104207248e5fe015cfd1c495fe">
        <source>3  Overall Conclusions</source>
        <target>3 Conclusions générales</target>
      </trans-unit>
      <trans-unit id="340" resname="66a9f6096b0eb7d973249bc8108116f3">
        <source>Elrond  is  the  first  highly  scalable  public  blockchain  that uses  the  newly  proposed  Secure  Proof  of  Stake  algorithm in   a   genuine   state-sharded   architecture   to   achieve   VISA level throughput and confirmation times of seconds. Elrond’s novel  approach  on  adaptive  state  sharding  improves  on  Om- niledger’s proposal increasing security and throughput, while the built-in automatic transaction routing and state redundancy mechanisms  considerably  reduce  latencies.  By  using  a  shard pruning  technique  the  bootstrapping  and  storage  costs  are also considerably reduced compared to other approaches. The newly introduced Secure Proof of Stake consensus algorithm ensures distributed fairness and improves on Algorand’s idea of random selection, reducing the time needed for the random selection  of  the  consensus  group  from  12  seconds  to  100 ms.  Our  method  of  combining  state  sharding  and  the  very efficient Secure Proof of Stake consensus algorithm has shown promising  results  in  our  initial  estimations,  validated  by  our latest testnet results.</source>
        <target>Elrond est la première BlockChain publique hautement scalable qui utilise l'algorithme récemment proposé de Preuve d'Enjeu Sécurisée (SPoS) dans une véritable architecture de Sharding d'état pour atteindre un débit équivalent à celui de VISA et des temps de confirmation de quelques secondes. L'approche novatrice d'Elrond sur le Sharding d'états adaptatif améliore la proposition d'Omniledger en augmentant la sécurité et le débit, tandis que le routage automatique des transactions et les mécanismes intégrés de redondance d'états réduisent considérablement les temps de latence. En utilisant une technique de suppression des Shards, les coûts d'amorçage et de stockage sont également considérablement réduits par rapport aux autres approches. L'algorithme de consensus de Preuve d'Enjeu Sécurisée (SPoS) récemment introduit garantit une équité distribuée et améliore l'idée de sélection aléatoire d'Algorand, en réduisant le temps nécessaire pour la sélection aléatoire du groupe de consensus de 12 secondes à 100 ms. Notre méthode de combinaison du Sharding d'états et du très efficace algorithme de consensus de Preuve d'Enjeu Sécurisée (SPoS) a donné des résultats prometteurs dans nos estimations initiales, validées par les derniers résultats de notre testnet.</target>
      </trans-unit>
      <trans-unit id="341" resname="1481aba130fba26eca3019c558d18ab8">
        <source>References</source>
        <target>References</target>
      </trans-unit>
      <trans-unit id="342" resname="cbed2f8407edf43b114a5809e645973a">
        <source>[1]  G.    Hileman    and    M.    Rauchs,    “2017    Global    Cryptocurrency Benchmarking  Study,”  Social  Science  Research  Network,  Rochester, NY, SSRN Scholarly Paper ID 2965436, Apr. 2017. [Online]. Available: https://papers.ssrn.com/abstract=2965436</source>
        <target>[1]  G.    Hileman    and    M.    Rauchs,    “2017    Global    Cryptocurrency Benchmarking  Study,”  Social  Science  Research  Network,  Rochester, NY, SSRN Scholarly Paper ID 2965436, Apr. 2017. [Online]. Available: https://papers.ssrn.com/abstract=2965436</target>
      </trans-unit>
      <trans-unit id="343" resname="3042f7edf6123edd9aef9642342ec166">
        <source>[2]  “The  Ethereum  Wiki  -  Sharding  FAQ,”  2018,  original-date:  2014-02-</source>
        <target>[2]  “The  Ethereum  Wiki  -  Sharding  FAQ,”  2018,  original-date:  2014-02-</target>
      </trans-unit>
      <trans-unit id="344" resname="58e58656a70908d2c9ef9e60443c7483">
        <source>14T23:05:17Z.  [Online].  Available:  https://github.com/ethereum/wiki/</source>
        <target>14T23:05:17Z.  [Online].  Available:  https://github.com/ethereum/wiki/</target>
      </trans-unit>
      <trans-unit id="345" resname="692e8e0903bdcba200b9af7c82ad1af9">
        <source>wiki/Sharding-FAQ</source>
        <target>wiki/Sharding-FAQ</target>
      </trans-unit>
      <trans-unit id="346" resname="71616b48ed63fe4596680020f2d4dc48">
        <source>[3]  Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich, “Algorand: Scaling Byzantine Agreements for Cryptocurrencies,” in Proceedings of the  26th  Symposium  on  Operating  Systems  Principles,  ser.  SOSP  ’17. New  York,  NY,  USA:  ACM,  2017,  pp.  51–68.  [Online].  Available: http://doi.acm.org/10.1145/3132747.3132757</source>
        <target>[3]  Y. Gilad, R. Hemo, S. Micali, G. Vlachos, and N. Zeldovich, “Algorand: Scaling Byzantine Agreements for Cryptocurrencies,” in Proceedings of the  26th  Symposium  on  Operating  Systems  Principles,  ser.  SOSP  ’17. New  York,  NY,  USA:  ACM,  2017,  pp.  51–68.  [Online].  Available: http://doi.acm.org/10.1145/3132747.3132757</target>
      </trans-unit>
      <trans-unit id="347" resname="0dd3219c7c4ac30615af63439214836f">
        <source>[4]  D.  Boneh,  B.  Lynn,  and  H.  Shacham,  “Short  signatures  from  the  weil pairing,” in Advances in Cryptology – ASIACRYPT ’01, LNCS.  Springer,</source>
        <target>[4]  D.  Boneh,  B.  Lynn,  and  H.  Shacham,  “Short  signatures  from  the  weil pairing,” in Advances in Cryptology – ASIACRYPT ’01, LNCS.  Springer,</target>
      </trans-unit>
      <trans-unit id="348" resname="8de338c7f44aa5bb6fe407a70d806076">
        <source>2001, pp. 514–532.</source>
        <target>2001, pp. 514–532.</target>
      </trans-unit>
      <trans-unit id="349" resname="eecb371cc08a9ae01521fec3331e746e">
        <source>[5]  D.  Boneh,  M.  Drijvers,  and  G.  Neven,  “Compact  multi-signatures  for smaller  blockchains,”  in  Advances  in  Cryptology  –  ASIACRYPT  2018, ser.  Lecture  Notes  in  Computer  Science,  vol.  11273.    Springer,  2018, pp. 435–464.</source>
        <target>[5]  D.  Boneh,  M.  Drijvers,  and  G.  Neven,  “Compact  multi-signatures  for smaller  blockchains,”  in  Advances  in  Cryptology  –  ASIACRYPT  2018, ser.  Lecture  Notes  in  Computer  Science,  vol.  11273.    Springer,  2018, pp. 435–464.</target>
      </trans-unit>
      <trans-unit id="350" resname="983f1b46364ff2a70cd9bc821ee92bbf">
        <source>[6]  V.   Buterin,   “Ethereum:   A   Next-Generation   Smart   Contract   and</source>
        <target>[6]  V.   Buterin,   “Ethereum:   A   Next-Generation   Smart   Contract   and</target>
      </trans-unit>
      <trans-unit id="351" resname="f018fb0bd4e6c139cfea5fac03c9c334">
        <source>Decentralized  Application  Platform,”  2013.  [Online].  Available:  https:</source>
        <target>Decentralized  Application  Platform,”  2013.  [Online].  Available:  https:</target>
      </trans-unit>
      <trans-unit id="352" resname="40b8593168d0f741e373184e26c8f6b5">
        <source>//www.ethereum.org/pdfs/EthereumWhitePaper.pdf</source>
        <target>//www.ethereum.org/pdfs/EthereumWhitePaper.pdf</target>
      </trans-unit>
      <trans-unit id="353" resname="e553a2b3552219478654bff589de9eaf">
        <source>[7]  E.   Kokoris-Kogias,   P.   Jovanovic,   L.   Gasser,   N.   Gailly,   E.   Syta, and   B.   Ford,   “OmniLedger:   A   Secure,   Scale-Out,   Decentralized Ledger   via   Sharding,”   Tech.   Rep.   406,   2017.   [Online].   Available: https://eprint.iacr.org/2017/406</source>
        <target>[7]  E.   Kokoris-Kogias,   P.   Jovanovic,   L.   Gasser,   N.   Gailly,   E.   Syta, and   B.   Ford,   “OmniLedger:   A   Secure,   Scale-Out,   Decentralized Ledger   via   Sharding,”   Tech.   Rep.   406,   2017.   [Online].   Available: https://eprint.iacr.org/2017/406</target>
      </trans-unit>
      <trans-unit id="354" resname="af15fa73968f54becb6cf9af746712aa">
        <source>[8]  “The   ZILLIQA   Technical   Whitepaper,”   2017.   [Online].   Available:</source>
        <target>[8]  “The   ZILLIQA   Technical   Whitepaper,”   2017.   [Online].   Available:</target>
      </trans-unit>
      <trans-unit id="355" resname="092faa5238a60df4f73a9005ca275d9d">
        <source>https://docs.zilliqa.com/whitepaper.pdf</source>
        <target>https://docs.zilliqa.com/whitepaper.pdf</target>
      </trans-unit>
      <trans-unit id="356" resname="21b7aef86d07c574aad02c4abdd6008d">
        <source>[9]  M.  Al-Bassam,  A.  Sonnino,  S.  Bano,  D.  Hrycyszyn,  and  G.  Danezis, “Chainspace: A Sharded Smart Contracts Platform,” arXiv:1708.03778 [cs],   Aug.   2017,   arXiv:   1708.03778.   [Online].   Available:   http:</source>
        <target>[9]  M.  Al-Bassam,  A.  Sonnino,  S.  Bano,  D.  Hrycyszyn,  and  G.  Danezis, “Chainspace: A Sharded Smart Contracts Platform,” arXiv:1708.03778 [cs],   Aug.   2017,   arXiv:   1708.03778.   [Online].   Available:   http:</target>
      </trans-unit>
      <trans-unit id="357" resname="af6396e36afd76ed2481d7709a4f4e8c">
        <source>//arxiv.org/abs/1708.03778</source>
        <target>//arxiv.org/abs/1708.03778</target>
      </trans-unit>
      <trans-unit id="358" resname="b076851fadf367e7a23b011d010eeb61">
        <source>[10]  G.     Wood,     “Ethereum:     A     Secure     Decentralised     Generalised Transaction   Ledger,”   2017.   [Online].   Available:   https://ethereum. github.io/yellowpaper/paper.pdf</source>
        <target>[10]  G.     Wood,     “Ethereum:     A     Secure     Decentralised     Generalised Transaction   Ledger,”   2017.   [Online].   Available:   https://ethereum. github.io/yellowpaper/paper.pdf</target>
      </trans-unit>
      <trans-unit id="359" resname="25868d7ec7d21129f2608330526e71f2">
        <source>[11]  “Solidity   —   Solidity   0.4.21   documentation.”   [Online].   Available:</source>
        <target>[11]  “Solidity   —   Solidity   0.4.21   documentation.”   [Online].   Available:</target>
      </trans-unit>
      <trans-unit id="360" resname="85185a6df1752d8bd2f6979b9487a7b5">
        <source>https://solidity.readthedocs.io/en/v0.4.21/</source>
        <target>https://solidity.readthedocs.io/en/v0.4.21/</target>
      </trans-unit>
      <trans-unit id="361" resname="a306606ac0221e925568857d45aa8e4f">
        <source>[12]  “web3j,” 2018. [Online]. Available: https://github.com/web3j</source>
        <target>[12]  “web3j,” 2018. [Online]. Available: https://github.com/web3j</target>
      </trans-unit>
      <trans-unit id="362" resname="d40fe80d485d552e148d7d46ebd9ff49">
        <source>[13]  “Casper,” 2018. [Online]. Available: http://ethresear.ch/c/casper</source>
        <target>[13]  “Casper,” 2018. [Online]. Available: http://ethresear.ch/c/casper</target>
      </trans-unit>
      <trans-unit id="363" resname="940fd166b6146957e2845fe41499c975">
        <source>[14]  “The   State   of   Ethereum   Scaling,   March   2018   –   Highlights   from EthCC  on  Plasma  Cash,  Minimum  Viable  Plasma,  and  More. . .   – Medium,” 2018. [Online]. Available: https://medium.com/loom-network/ the-state-of-ethereum-scaling-march-2018-74ac08198a36</source>
        <target>[14]  “The   State   of   Ethereum   Scaling,   March   2018   –   Highlights   from EthCC  on  Plasma  Cash,  Minimum  Viable  Plasma,  and  More. . .   – Medium,” 2018. [Online]. Available: https://medium.com/loom-network/ the-state-of-ethereum-scaling-march-2018-74ac08198a36</target>
      </trans-unit>
      <trans-unit id="364" resname="06093dacc4082bd9b828b303a5294be2">
        <source>[15]  M.   Castro   and   B.   Liskov,   “Practical   Byzantine   Fault   Tolerance,” in   Proceedings   of   the   Third   Symposium   on   Operating   Systems Design  and  Implementation,  ser.  OSDI  ’99.     Berkeley,  CA,  USA: USENIX    Association,    1999,    pp.    173–186.    [Online].    Available: http://dl.acm.org/citation.cfm?id=296806.296824</source>
        <target>[15]  M.   Castro   and   B.   Liskov,   “Practical   Byzantine   Fault   Tolerance,” in   Proceedings   of   the   Third   Symposium   on   Operating   Systems Design  and  Implementation,  ser.  OSDI  ’99.     Berkeley,  CA,  USA: USENIX    Association,    1999,    pp.    173–186.    [Online].    Available: http://dl.acm.org/citation.cfm?id=296806.296824</target>
      </trans-unit>
      <trans-unit id="365" resname="3aa855a7d2aa1e0e9dc2bc4a0d54f105">
        <source>[16]  Y.   Jia,   “Op   Ed:   The   Many   Faces   of   Sharding   for   Blockchain Scalability,”   2018.   [Online].   Available:   https://bitcoinmagazine.com/ articles/op-ed-many-faces-sharding-blockchain-scalability/</source>
        <target>[16]  Y.   Jia,   “Op   Ed:   The   Many   Faces   of   Sharding   for   Blockchain Scalability,”   2018.   [Online].   Available:   https://bitcoinmagazine.com/ articles/op-ed-many-faces-sharding-blockchain-scalability/</target>
      </trans-unit>
      <trans-unit id="366" resname="7164bdb57cb27c31b667d3e629b21295">
        <source>[17]  “Using    Merklix    tree    to    shard    block    validation    |    Deadalnix’s den,”  2016.  [Online].  Available:  https://www.deadalnix.me/2016/11/06/ using-merklix-tree-to-shard-block-validation/</source>
        <target>[17]  “Using    Merklix    tree    to    shard    block    validation    |    Deadalnix’s den,”  2016.  [Online].  Available:  https://www.deadalnix.me/2016/11/06/ using-merklix-tree-to-shard-block-validation/</target>
      </trans-unit>
      <trans-unit id="367" resname="a0c5f8dd5efc79c73cf68b1131ae0c68">
        <source>[18]  S.  Nakamoto,  “Bitcoin:  A  Peer-to-Peer  Electronic  Cash  System,”  p.  9,</source>
        <target>[18]  S.  Nakamoto,  “Bitcoin:  A  Peer-to-Peer  Electronic  Cash  System,”  p.  9,</target>
      </trans-unit>
      <trans-unit id="368" resname="b4fb67f482225df45fc733c52f51f9a9">
        <source>2008.</source>
        <target>2008.</target>
      </trans-unit>
      <trans-unit id="369" resname="376eee1ea3163f0d99b071ec7a004df1">
        <source>[19]  “Why  we  are  building  Cardano  -  Introduction.”  [Online].  Available:</source>
        <target>[19]  “Why  we  are  building  Cardano  -  Introduction.”  [Online].  Available:</target>
      </trans-unit>
      <trans-unit id="370" resname="522fe04b1b5fc7ecf60e42b954cc664e">
        <source>https://whycardano.com/</source>
        <target>https://whycardano.com/</target>
      </trans-unit>
      <trans-unit id="371" resname="ec9cf8c6da4e77902cfed5d088755b26">
        <source>[20]  “Constellation  -  a  blockchain  microservice  operating  system  -  White Paper,” 2017, original-date: 2018-01-05T20:42:05Z. [Online]. Available: https://github.com/Constellation-Labs/Whitepaper</source>
        <target>[20]  “Constellation  -  a  blockchain  microservice  operating  system  -  White Paper,” 2017, original-date: 2018-01-05T20:42:05Z. [Online]. Available: https://github.com/Constellation-Labs/Whitepaper</target>
      </trans-unit>
      <trans-unit id="372" resname="63c0335e03655e0f92e85dd58bb08dde">
        <source>[21]  “Bitshares          -          Delegated          Proof-of-Stake          Consensus,”</source>
        <target>[21]  “Bitshares          -          Delegated          Proof-of-Stake          Consensus,”</target>
      </trans-unit>
      <trans-unit id="373" resname="6df00ce98a593ff2001256d33c1ee594">
        <source>2014.        [Online].        Available:        https://bitshares.org/technology/</source>
        <target>2014.        [Online].        Available:        https://bitshares.org/technology/</target>
      </trans-unit>
      <trans-unit id="374" resname="4f4b37a46bc0a1ccd53663eb85837dca">
        <source>delegated-proof-of-stake-consensus/</source>
        <target>delegated-proof-of-stake-consensus/</target>
      </trans-unit>
      <trans-unit id="375" resname="a766c8d54d532f3e7894ceb1351cf282">
        <source>[22]  dantheman, “DPOS Consensus Algorithm - The Missing White Paper,” May  2017.  [Online].  Available:  https://steemit.com/dpos/@dantheman/ dpos-consensus-algorithm-this-missing-white-paper</source>
        <target>[22]  dantheman, “DPOS Consensus Algorithm - The Missing White Paper,” May  2017.  [Online].  Available:  https://steemit.com/dpos/@dantheman/ dpos-consensus-algorithm-this-missing-white-paper</target>
      </trans-unit>
      <trans-unit id="376" resname="20602fa400a9791e884901556ed998dc">
        <source>[23]  “EOS.IO   Technical   White   Paper   v2,”   2018,   original-date:   2017-</source>
        <target>[23]  “EOS.IO   Technical   White   Paper   v2,”   2018,   original-date:   2017-</target>
      </trans-unit>
      <trans-unit id="377" resname="4eae676d9042859511d51f3cadbc1de2">
        <source>06-06T07:55:17Z.    [Online].    Available:    https://github.com/EOSIO/ Documentation/blob/master/TechnicalWhitePaper.md</source>
        <target>06-06T07:55:17Z.    [Online].    Available:    https://github.com/EOSIO/ Documentation/blob/master/TechnicalWhitePaper.md</target>
      </trans-unit>
      <trans-unit id="378" resname="7092ce993f4a4771700470e16e8e6a90">
        <source>[24]  C.  Paar  and  J.  Pelzl,  Understanding  Cryptography:  A  Textbook  for Students and Practitioners.    Berlin Heidelberg: Springer-Verlag, 2010. [Online]. Available: //www.springer.com/gp/book/9783642041006</source>
        <target>[24]  C.  Paar  and  J.  Pelzl,  Understanding  Cryptography:  A  Textbook  for Students and Practitioners.    Berlin Heidelberg: Springer-Verlag, 2010. [Online]. Available: //www.springer.com/gp/book/9783642041006</target>
      </trans-unit>
      <trans-unit id="379" resname="fa7e6d13fe57826f3544e39b41236223">
        <source>[25]  C. Schnorr, “Efficient signature generation by smart cards,” Journal of</source>
        <target>[25]  C. Schnorr, “Efficient signature generation by smart cards,” Journal of</target>
      </trans-unit>
      <trans-unit id="380" resname="a22cf3cb181184539cd257f91d1f5c1d">
        <source>Cryptology, vol. 4, pp. 161–174, Jan. 1991.</source>
        <target>Cryptology, vol. 4, pp. 161–174, Jan. 1991.</target>
      </trans-unit>
      <trans-unit id="381" resname="992f8db8eabd388b9474e3bc4be45a1d">
        <source>[26]  K.   Michaelis,   C.   Meyer,   and   J.   Schwenk,   “Randomly   Failed!</source>
        <target>[26]  K.   Michaelis,   C.   Meyer,   and   J.   Schwenk,   “Randomly   Failed!</target>
      </trans-unit>
      <trans-unit id="382" resname="ce4ac81ba68f12be8978fcbfbb74b709">
        <source>The   State   of   Randomness   in   Current   Java   Implementations,”   in Topics   in   Cryptology   –   CT-RSA   2013,   ser.   Lecture   Notes   in Computer   Science.     Springer,   Berlin,   Heidelberg,   Feb.   2013,   pp.</source>
        <target>The   State   of   Randomness   in   Current   Java   Implementations,”   in Topics   in   Cryptology   –   CT-RSA   2013,   ser.   Lecture   Notes   in Computer   Science.     Springer,   Berlin,   Heidelberg,   Feb.   2013,   pp.</target>
      </trans-unit>
      <trans-unit id="383" resname="3db0bee4e2339842254c38c35eda663b">
        <source>129–144. [Online]. Available: https://link.springer.com/chapter/10.1007/</source>
        <target>129–144. [Online]. Available: https://link.springer.com/chapter/10.1007/</target>
      </trans-unit>
      <trans-unit id="384" resname="f826935e11f841331da8ec35d3fac057">
        <source>978-3-642-36095-4  9</source>
        <target>978-3-642-36095-4  9</target>
      </trans-unit>
      <trans-unit id="385" resname="6a77bd51d9d77188860db75a1b582226">
        <source>[27]  D. J. Bernstein, P. Birkner, M. Joye, T. Lange, and C. Peters, “Twisted</source>
        <target>[27]  D. J. Bernstein, P. Birkner, M. Joye, T. Lange, and C. Peters, “Twisted</target>
      </trans-unit>
      <trans-unit id="386" resname="06afbb1a1365f9ab271d1b97e1c15b82">
        <source>Edwards   Curves,”   in   Progress   in   Cryptology   –   AFRICACRYPT</source>
        <target>Edwards   Curves,”   in   Progress   in   Cryptology   –   AFRICACRYPT</target>
      </trans-unit>
      <trans-unit id="387" resname="f55cb027a78a1bd3d9ef188470c734e2">
        <source>2008,   ser.   Lecture   Notes   in   Computer   Science.     Springer,   Berlin, Heidelberg,   Jun.   2008,   pp.   389–405.   [Online].   Available:   https:</source>
        <target>2008,   ser.   Lecture   Notes   in   Computer   Science.     Springer,   Berlin, Heidelberg,   Jun.   2008,   pp.   389–405.   [Online].   Available:   https:</target>
      </trans-unit>
      <trans-unit id="388" resname="4ddf7711a6416c8ff9fefcb940677543">
        <source>//link.springer.com/chapter/10.1007/978-3-540-68164-9  26</source>
        <target>//link.springer.com/chapter/10.1007/978-3-540-68164-9  26</target>
      </trans-unit>
      <trans-unit id="389" resname="50cfd88c37ecdc7d166b1e2262ced13b">
        <source>[28]  A.  Poelstra,  “Schnorr  Signatures  are  Non-Malleable  in  the  Random Oracle Model,” 2014. [Online]. Available: https://download.wpsoftware. net/bitcoin/wizardry/schnorr-mall.pdf</source>
        <target>[28]  A.  Poelstra,  “Schnorr  Signatures  are  Non-Malleable  in  the  Random Oracle Model,” 2014. [Online]. Available: https://download.wpsoftware. net/bitcoin/wizardry/schnorr-mall.pdf</target>
      </trans-unit>
      <trans-unit id="390" resname="2e605aee7f4988f4d4a5e428e6dd9ded">
        <source>[29]  C.  Decker  and  R.  Wattenhofer,  “Bitcoin  Transaction  Malleability  and</source>
        <target>[29]  C.  Decker  and  R.  Wattenhofer,  “Bitcoin  Transaction  Malleability  and</target>
      </trans-unit>
      <trans-unit id="391" resname="1b92061e4a39ee55635dc552e7999ae7">
        <source>MtGox,”  arXiv:1403.6676  [cs],  vol.  8713,  pp.  313–326,  2014,  arXiv:</source>
        <target>MtGox,”  arXiv:1403.6676  [cs],  vol.  8713,  pp.  313–326,  2014,  arXiv:</target>
      </trans-unit>
      <trans-unit id="392" resname="ca5b171e868c2bab3a6612755f5d1ad5">
        <source>1403.6676. [Online]. Available: http://arxiv.org/abs/1403.6676</source>
        <target>1403.6676. [Online]. Available: http://arxiv.org/abs/1403.6676</target>
      </trans-unit>
      <trans-unit id="393" resname="5af34161b058a158a55459b4000af7cd">
        <source>[30]  G.  Maxwell,  A.  Poelstra,  Y.  Seurin,  and  P.  Wuille,  “Simple  Schnorr Multi-Signatures  with  Applications  to  Bitcoin,”  Tech.  Rep.  068,  2018. [Online]. Available: https://eprint.iacr.org/2018/068</source>
        <target>[30]  G.  Maxwell,  A.  Poelstra,  Y.  Seurin,  and  P.  Wuille,  “Simple  Schnorr Multi-Signatures  with  Applications  to  Bitcoin,”  Tech.  Rep.  068,  2018. [Online]. Available: https://eprint.iacr.org/2018/068</target>
      </trans-unit>
      <trans-unit id="394" resname="55527e877c9e02784d8a12395dccb98c">
        <source>[31]  Y.   Seurin,   “On   the   Exact   Security   of   Schnorr-Type   Signatures in   the   Random   Oracle   Model,”   in   Advances   in   Cryptology   – EUROCRYPT 2012, ser. Lecture Notes in Computer Science.   Springer, Berlin,   Heidelberg,   Apr.   2012,   pp.   554–571.   [Online].   Available: https://link.springer.com/chapter/10.1007/978-3-642-29011-4  33</source>
        <target>[31]  Y.   Seurin,   “On   the   Exact   Security   of   Schnorr-Type   Signatures in   the   Random   Oracle   Model,”   in   Advances   in   Cryptology   – EUROCRYPT 2012, ser. Lecture Notes in Computer Science.   Springer, Berlin,   Heidelberg,   Apr.   2012,   pp.   554–571.   [Online].   Available: https://link.springer.com/chapter/10.1007/978-3-642-29011-4  33</target>
      </trans-unit>
      <trans-unit id="395" resname="1124e96f7e2236aca4ea57423b93879d">
        <source>[32]  K.  Itakura  and  K.  Nakamura,  “A  public-key  cryptosystem  suitable  for digital multisignatures,” 1983.</source>
        <target>[32]  K.  Itakura  and  K.  Nakamura,  “A  public-key  cryptosystem  suitable  for digital multisignatures,” 1983.</target>
      </trans-unit>
      <trans-unit id="396" resname="dd74a359d80d5beb60274924ee57362f">
        <source>[33]  S.    Micali,    K.    Ohta,    and    L.    Reyzin,    “Accountable-subgroup Multisignatures:   Extended   Abstract,”   in   Proceedings   of   the   8th ACM  Conference  on  Computer  and  Communications  Security,  ser. CCS  ’01.    New  York,  NY,  USA:  ACM,  2001,  pp.  245–254.  [Online]. Available: http://doi.acm.org/10.1145/501983.502017</source>
        <target>[33]  S.    Micali,    K.    Ohta,    and    L.    Reyzin,    “Accountable-subgroup Multisignatures:   Extended   Abstract,”   in   Proceedings   of   the   8th ACM  Conference  on  Computer  and  Communications  Security,  ser. CCS  ’01.    New  York,  NY,  USA:  ACM,  2001,  pp.  245–254.  [Online]. Available: http://doi.acm.org/10.1145/501983.502017</target>
      </trans-unit>
      <trans-unit id="397" resname="a5039371f035cd88162c9b3fb15fcee9">
        <source>[34]  T.   Ristenpart   and   S.   Yilek,   “The   Power   of   Proofs-of-Possession: Securing    Multiparty    Signatures    against    Rogue-Key    Attacks,”    in Advances   in   Cryptology   -   EUROCRYPT   2007,   ser.   Lecture   Notes in  Computer  Science.    Springer,  Berlin,  Heidelberg,  May  2007,  pp.</source>
        <target>[34]  T.   Ristenpart   and   S.   Yilek,   “The   Power   of   Proofs-of-Possession: Securing    Multiparty    Signatures    against    Rogue-Key    Attacks,”    in Advances   in   Cryptology   -   EUROCRYPT   2007,   ser.   Lecture   Notes in  Computer  Science.    Springer,  Berlin,  Heidelberg,  May  2007,  pp.</target>
      </trans-unit>
      <trans-unit id="398" resname="2fb56fb8523be571dc4618dd87bef1f7">
        <source>228–245. [Online]. Available: https://link.springer.com/chapter/10.1007/</source>
        <target>228–245. [Online]. Available: https://link.springer.com/chapter/10.1007/</target>
      </trans-unit>
      <trans-unit id="399" resname="6afdc8fd3ca1378dabcfbb81b7ebbbca">
        <source>978-3-540-72540-4  13</source>
        <target>978-3-540-72540-4  13</target>
      </trans-unit>
      <trans-unit id="400" resname="e8e8577423bc0ca5185a29d46c8739eb">
        <source>[35]  M.  Bellare  and  G.  Neven,  “Multi-signatures  in  the  Plain  public-Key Model  and  a  General  Forking  Lemma,”  in  Proceedings  of  the  13th ACM  Conference  on  Computer  and  Communications  Security,  ser. CCS  ’06.    New  York,  NY,  USA:  ACM,  2006,  pp.  390–399.  [Online]. Available: http://doi.acm.org/10.1145/1180405.1180453</source>
        <target>[35]  M.  Bellare  and  G.  Neven,  “Multi-signatures  in  the  Plain  public-Key Model  and  a  General  Forking  Lemma,”  in  Proceedings  of  the  13th ACM  Conference  on  Computer  and  Communications  Security,  ser. CCS  ’06.    New  York,  NY,  USA:  ACM,  2006,  pp.  390–399.  [Online]. Available: http://doi.acm.org/10.1145/1180405.1180453</target>
      </trans-unit>
      <trans-unit id="401" resname="92923039f3abf1a2a2abc9b083cec43f">
        <source>[36]  D.-P.  Le,  A.  Bonnecaze,  and  A.  Gabillon,  “Multisignatures  as  Secure as  the  Diffie-Hellman  Problem  in  the  Plain  Public-Key  Model,”  in Pairing-Based  Cryptography  –  Pairing  2009,  ser.  Lecture  Notes  in Computer   Science.     Springer,   Berlin,   Heidelberg,   Aug.   2009,   pp.</source>
        <target>[36]  D.-P.  Le,  A.  Bonnecaze,  and  A.  Gabillon,  “Multisignatures  as  Secure as  the  Diffie-Hellman  Problem  in  the  Plain  Public-Key  Model,”  in Pairing-Based  Cryptography  –  Pairing  2009,  ser.  Lecture  Notes  in Computer   Science.     Springer,   Berlin,   Heidelberg,   Aug.   2009,   pp.</target>
      </trans-unit>
      <trans-unit id="402" resname="d0f4e6cf83d4637456a5fbbeafc36409">
        <source>35–51.   [Online].   Available:   https://link.springer.com/chapter/10.1007/</source>
        <target>35–51.   [Online].   Available:   https://link.springer.com/chapter/10.1007/</target>
      </trans-unit>
      <trans-unit id="403" resname="a5981240b856884e5d4d3fa06f03b7f0">
        <source>978-3-642-03298-1  3</source>
        <target>978-3-642-03298-1  3</target>
      </trans-unit>
      <trans-unit id="404" resname="d4777b0d96dcb75615b2e7c415d8e196">
        <source>[37]  T.   Dickerson,  P.   Gazzillo,  M.   Herlihy,  and   E.  Koskinen,   “Adding Concurrency   to   Smart   Contracts,”   in   Proceedings   of   the   ACM Symposium  on  Principles  of  Distributed  Computing,  ser.  PODC  ’17. New  York,  NY,  USA:  ACM,  2017,  pp.  303–312.  [Online].  Available: http://doi.acm.org/10.1145/3087801.3087835</source>
        <target>[37]  T.   Dickerson,  P.   Gazzillo,  M.   Herlihy,  and   E.  Koskinen,   “Adding Concurrency   to   Smart   Contracts,”   in   Proceedings   of   the   ACM Symposium  on  Principles  of  Distributed  Computing,  ser.  PODC  ’17. New  York,  NY,  USA:  ACM,  2017,  pp.  303–312.  [Online].  Available: http://doi.acm.org/10.1145/3087801.3087835</target>
      </trans-unit>
      <trans-unit id="405" resname="2a2684be9f721f6b56f0882c71f2744c">
        <source>[38]  J. Kwon and E. Buchman, “Cosmos Network - Internet of Blockchains,”</source>
        <target>[38]  J. Kwon and E. Buchman, “Cosmos Network - Internet of Blockchains,”</target>
      </trans-unit>
      <trans-unit id="406" resname="9525b17361fb4985fae2e868fb324277">
        <source>2017. [Online]. Available: https://cosmos.network/whitepaper</source>
        <target>2017. [Online]. Available: https://cosmos.network/whitepaper</target>
      </trans-unit>
      <trans-unit id="407" resname="e2d787e22d66f675554abb4c0bdfa3fe">
        <source>[39]  G.  Ros, u  and  T.  F.  S, erba˘nuta˘,  “An  overview  of  the  k  semantic  frame- work,” The Journal of Logic and Algebraic Programming, vol. 79, no. 6, pp. 397–434, 2010.</source>
        <target>[39]  G.  Ros, u  and  T.  F.  S, erba˘nuta˘,  “An  overview  of  the  k  semantic  frame- work,” The Journal of Logic and Algebraic Programming, vol. 79, no. 6, pp. 397–434, 2010.</target>
      </trans-unit>
      <trans-unit id="408" resname="c6c234d12c7182c14257b2a408f95967">
        <source>[40]  T.  Kasampalis,  D.  Guth,  B.  Moore,  T.  Serbanuta,  V.  Serbanuta,  D.  Fi- laretti, G. Rosu, and R. Johnson, “Iele: An intermediate-level blockchain language  designed  and  implemented  using  formal  semantics,”  Tech. Rep., 2018.</source>
        <target>[40]  T.  Kasampalis,  D.  Guth,  B.  Moore,  T.  Serbanuta,  V.  Serbanuta,  D.  Fi- laretti, G. Rosu, and R. Johnson, “Iele: An intermediate-level blockchain language  designed  and  implemented  using  formal  semantics,”  Tech. Rep., 2018.</target>
      </trans-unit>
      <trans-unit id="409" resname="fadd37301bcc3b49747bd4319d34bcd6">
        <source>[41]  E. Hildenbrandt, M. Saxena, X. Zhu, N. Rodrigues, P. Daian, D. Guth, and  G.  Rosu,  “Kevm:  A  complete  semantics  of  the  ethereum  virtual machine,” Tech. Rep., 2017.</source>
        <target>[41]  E. Hildenbrandt, M. Saxena, X. Zhu, N. Rodrigues, P. Daian, D. Guth, and  G.  Rosu,  “Kevm:  A  complete  semantics  of  the  ethereum  virtual machine,” Tech. Rep., 2017.</target>
      </trans-unit>
      <trans-unit id="410" resname="ae95ef9f4942feaf59acaafa7c6b8c85">
        <source>[42]  “How     Formal     Verification     of     Smart     Contracts     Works     | RV   Blog.”   [Online].   Available:   https://runtimeverification.com/blog/ how-formal-verification-of-smart-contracts-works/</source>
        <target>[42]  “How     Formal     Verification     of     Smart     Contracts     Works     | RV   Blog.”   [Online].   Available:   https://runtimeverification.com/blog/ how-formal-verification-of-smart-contracts-works/</target>
      </trans-unit>
      <trans-unit id="411" resname="6ef5c6208982914c22c00c406d5c0f5b">
        <source>[43]  “Cross-shard  contract  yanking.”  [Online].  Available:  https://ethresear. ch/t/cross-shard-contract-yanking/1450</source>
        <target>[43]  “Cross-shard  contract  yanking.”  [Online].  Available:  https://ethresear. ch/t/cross-shard-contract-yanking/1450</target>
      </trans-unit>
      <trans-unit id="412" resname="d55e9c8f5cec4375a7f3f82ee87ae271">
        <source>[44]  R. C. Merkle, “A Certified Digital Signature,” in Advances in Cryptology</source>
        <target>[44]  R. C. Merkle, “A Certified Digital Signature,” in Advances in Cryptology</target>
      </trans-unit>
      <trans-unit id="413" resname="72355b574898fa82361cfbed077a658e">
        <source>— CRYPTO’ 89 Proceedings, ser. Lecture Notes in Computer Science. Springer, New York, NY, Aug. 1989, pp. 218–238. [Online]. Available: https://link.springer.com/chapter/10.1007/0-387-34805-0  21</source>
        <target>— CRYPTO’ 89 Proceedings, ser. Lecture Notes in Computer Science. Springer, New York, NY, Aug. 1989, pp. 218–238. [Online]. Available: https://link.springer.com/chapter/10.1007/0-387-34805-0  21</target>
      </trans-unit>
      <trans-unit id="414" resname="e42a317ab06d3e125eecef0ee14979ef">
        <source>[45]  A.  Veysov  and  M.  Stolbov,  “Financial  System  Classification:  From Conventional  Dichotomy  to  a  More  Modern  View,”  Social  Science Research Network, Rochester, NY, SSRN Scholarly Paper ID 2114842, Jul. 2012. [Online]. Available: https://papers.ssrn.com/abstract=2114842</source>
        <target>[45]  A.  Veysov  and  M.  Stolbov,  “Financial  System  Classification:  From Conventional  Dichotomy  to  a  More  Modern  View,”  Social  Science Research Network, Rochester, NY, SSRN Scholarly Paper ID 2114842, Jul. 2012. [Online]. Available: https://papers.ssrn.com/abstract=2114842</target>
      </trans-unit>
      <trans-unit id="415" resname="6458c48805deb40dcc2c74f2b6e1035c">
        <source>[46]  “XRP   -   The   Digital   Asset   for   Payments.”   [Online].   Available:</source>
        <target>[46]  “XRP   -   The   Digital   Asset   for   Payments.”   [Online].   Available:</target>
      </trans-unit>
      <trans-unit id="416" resname="40cc88ed3c7cbc29276dfd692bf1a9ac">
        <source>https://ripple.com/xrp/</source>
        <target>https://ripple.com/xrp/</target>
      </trans-unit>
      <trans-unit id="417" resname="bedf0f4034c026b4ec7b62be041e2e76">
        <source>[47]  “Visa      -      Annual      Report      2017,”      2018.      [Online].      Avail- able:   https://s1.q4cdn.com/050606653/files/doc  financials/annual/2017/ Visa-2017-Annual-Report.pdf</source>
        <target>[47]  “Visa      -      Annual      Report      2017,”      2018.      [Online].      Avail- able:   https://s1.q4cdn.com/050606653/files/doc  financials/annual/2017/ Visa-2017-Annual-Report.pdf</target>
      </trans-unit>
      <trans-unit id="418" resname="8e12f0cd44d288a4ec5eaced12e540c2">
        <source>[48]  “PayPal    Reports    Fourth    Quarter    and    Full    Year    2017    Results (NASDAQ:PYPL),”     2018.     [Online].     Available:     https://investor. paypal-corp.com/releasedetail.cfm?releaseid=1055924</source>
        <target>[48]  “PayPal    Reports    Fourth    Quarter    and    Full    Year    2017    Results (NASDAQ:PYPL),”     2018.     [Online].     Available:     https://investor. paypal-corp.com/releasedetail.cfm?releaseid=1055924</target>
      </trans-unit>
      <trans-unit id="419" resname="b9635c8c3fe4244c2bc818a10f0dc076">
        <source>[49]  M.   Schwarz,   “Crypto   Transaction   Speeds   2018   -   All   the   Major Cryptocurrencies,”  2018.  [Online].  Available:  https://www.abitgreedy. com/transaction-speed/</source>
        <target>[49]  M.   Schwarz,   “Crypto   Transaction   Speeds   2018   -   All   the   Major Cryptocurrencies,”  2018.  [Online].  Available:  https://www.abitgreedy. com/transaction-speed/</target>
      </trans-unit>
      <trans-unit id="420" resname="a824b8fa4c6219725a0c20bf8ac8689d">
        <source>[50]  “The    Ethereum    Wiki    -    Mining,”    2018,    original-date:    2014-02-</source>
        <target>[50]  “The    Ethereum    Wiki    -    Mining,”    2018,    original-date:    2014-02-</target>
      </trans-unit>
      <trans-unit id="421" resname="7f01a5bb45bedfe94f21737310f077c6">
        <source>wiki/Mininghttps://github.com/ethereum/wiki</source>
        <target>wiki/Mininghttps://github.com/ethereum/wiki</target>
      </trans-unit>
      <trans-unit id="422" resname="e852bce6bdd2a8a3688e913220174f5a">
        <source>[51]  “Transaction  throughput.”  [Online].  Available:  https://docs.oracle.com/</source>
        <target>[51]  “Transaction  throughput.”  [Online].  Available:  https://docs.oracle.com/</target>
      </trans-unit>
      <trans-unit id="423" resname="169714e6950f8b744bf68c5d3e67e2e2">
        <source>cd/E17276  01/html/programmer  reference/transapp  throughput.html</source>
        <target>cd/E17276  01/html/programmer  reference/transapp  throughput.html</target>
      </trans-unit>
      <trans-unit id="424" resname="6b7c77632855fbcbca0d0017d7d869a4">
        <source>[52]  W.  Martino,  M.  Quaintance,  and  S.  Popejoy,  “Chainweb:  A  Proof- of-Work  Parallel-Chain  Architecture  for  Massive  Throughput,”  2018. [Online]. Available: http://kadena.io/docs/chainweb-v15.pd</source>
        <target>[52]  W.  Martino,  M.  Quaintance,  and  S.  Popejoy,  “Chainweb:  A  Proof- of-Work  Parallel-Chain  Architecture  for  Massive  Throughput,”  2018. [Online]. Available: http://kadena.io/docs/chainweb-v15.pd</target>
      </trans-unit>
      <trans-unit id="425" resname="9352275fb398fca1ea15bfc3e5e03c5e">
        <source>[53]  “DIF    -    Decentralized    Identity    Foundation.”    [Online].    Available:</source>
        <target>[53]  “DIF    -    Decentralized    Identity    Foundation.”    [Online].    Available:</target>
      </trans-unit>
      <trans-unit id="426" resname="e7d315f71307f236a5d719970ebededb">
        <source>http://identity.foundation/</source>
        <target>http://identity.foundation/</target>
      </trans-unit>
      <trans-unit id="427" resname="a914eda53af9d8d349afe1154c07f3a0">
        <source>		[54]  H.        I.        World,        “Blockchain        Interoperability        Alliance: ICON	x          Aion          x          Wanchain,”          Dec.          2017. [Online].		Available:              https://medium.com/helloiconworld/ blockchain-interoperability-alliance-icon-x-aion-x-wanchain-8aeaafb3ebdd</source>
        <target>		[54]  H.        I.        World,        “Blockchain        Interoperability        Alliance: ICON	x          Aion          x          Wanchain,”          Dec.          2017. [Online].		Available:              https://medium.com/helloiconworld/ blockchain-interoperability-alliance-icon-x-aion-x-wanchain-8aeaafb3ebdd</target>
      </trans-unit>
      <trans-unit id="428" resname="eae3289549d19cd50cb72b0ac74e6300">
        <source>[55]  S. Goldwasser, S. Micali, and C. Rackoff, “The Knowledge Complexity of Interactive Proof-systems,” in Proceedings of the Seventeenth Annual ACM  Symposium  on  Theory  of  Computing,  ser.  STOC  ’85.     New York,   NY,   USA:   ACM,   1985,   pp.   291–304.   [Online].   Available: http://doi.acm.org/10.1145/22145.22178</source>
        <target>[55]  S. Goldwasser, S. Micali, and C. Rackoff, “The Knowledge Complexity of Interactive Proof-systems,” in Proceedings of the Seventeenth Annual ACM  Symposium  on  Theory  of  Computing,  ser.  STOC  ’85.     New York,   NY,   USA:   ACM,   1985,   pp.   291–304.   [Online].   Available: http://doi.acm.org/10.1145/22145.22178</target>
      </trans-unit>
    </body>
  </file>
</xliff>